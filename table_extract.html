{% extends 'base.html' %}
{% load static %}
{% load crispy_forms_tags %}

{% block title %}Table Extraction - PDF Tool{% endblock %}

{% block extra_css %}
<!-- Add CSRF Token meta tag -->
<meta name="csrf-token" content="{{ csrf_token }}">
<!-- Google Fonts - Inter -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<!-- Fira Code for monospace text -->
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">

<style>
    /* 
     * Table Extract Styles
     * This file inherits color theme variables from base.html
     * All color-related styles use CSS variables defined in base.html
     * Do not add custom color overrides here
     */
    
    /* Remove custom root variables to inherit from base.html */
    
    /* Animation keyframes */
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    @keyframes fadeOut {
        from { opacity: 1; }
        to { opacity: 0; }
    }
    
    @keyframes slideDown {
        from { transform: translateY(-10px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }
    
    .main-content {
        display: flex;
        height: calc(100vh - 200px);
        min-height: 600px;
        gap: 25px;
        margin-top: 20px;
    }

    .left-panel {
        flex: 3;
        display: flex;
        flex-direction: column;
        min-width: 0;
        overflow: hidden;
    }

    .right-panel {
        flex: 2;
        display: flex;
        flex-direction: column;
        min-width: 0;
        overflow: hidden;
    }

    /* Settings Panel Styles with Theme Variables */
    .settings-panel {
        background-color: var(--card-bg);
        border-radius: 8px;
        padding: 16px;
        box-shadow: 0 2px 8px var(--shadow-color, rgba(0, 0, 0, 0.1));
        width: 100%;
        border: 1px solid var(--border-color);
    }

    .settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 12px;
        margin-bottom: 12px;
    }

    .setting-group {
        display: flex;
        flex-direction: column;
        margin-bottom: 8px;
    }

    .setting-label {
        font-size: 0.8rem;
        color: var(--text-muted);
        margin-bottom: 4px;
        font-weight: 500;
    }

    .setting-input {
        background-color: var(--input-bg);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-color);
        padding: 6px 8px;
        font-size: 0.9rem;
        width: 100%;
        transition: border-color 0.2s;
    }

    .setting-input:focus {
        border-color: var(--primary-color, var(--primary));
        box-shadow: 0 0 0 1px var(--primary-light);
        outline: none;
    }

    /* Advanced settings */
    .advanced-settings-row {
        display: grid;
        grid-template-columns: 1fr;
        gap: 16px;
    }

    .adv-setting-group {
        display: flex;
        flex-direction: column;
    }

    .setting-textarea {
        background-color: var(--input-bg);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-color);
        padding: 8px;
        font-size: 0.9rem;
        height: 80px;
        font-family: 'Fira Code', monospace;
        transition: border-color 0.2s;
    }

    .setting-textarea:focus {
        border-color: var(--primary-color, var(--primary));
        box-shadow: 0 0 0 1px var(--primary-light);
        outline: none;
    }

    .setting-help {
        font-size: 0.75rem;
        color: var(--text-muted);
        margin-top: 4px;
    }

    /* Make the layout responsive */
    @media (max-width: 768px) {
        .advanced-settings-row {
            grid-template-columns: 1fr;
        }
        
        .settings-grid {
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        }
    }

    .pdf-preview-container {
        height: calc(100vh - 260px);
        min-height: 500px;
        border: none;
        border-radius: var(--border-radius);
        overflow: hidden;
        background-color: var(--bg-light);
        position: relative;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        box-shadow: var(--card-shadow);
        width: 100%;
    }

    /* Add scrollable content area */
    .pdf-content {
        flex: 1;
        overflow: auto;
        position: relative;
        background-color: var(--bg-light);
        width: 100%;
        height: 100%;
    }

    .pdf-canvas-wrapper {
        display: flex;
        justify-content: center;
        padding: 20px;
        min-height: 100%;
        min-width: fit-content; /* Ensure wrapper is at least as wide as the canvas */
    }

    .pdf-canvas-container {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    canvas#pdf-canvas {
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        background-color: var(--card-bg);
    }

    .table-preview-container {
        flex: 1;
        background: var(--card-bg);
        border-radius: var(--border-radius);
        box-shadow: var(--card-shadow);
        overflow: auto;
        padding: 20px;
    }

    .settings-form {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
    }

    .form-group {
        margin-bottom: 15px;
    }

    .form-label {
        font-weight: 500;
        color: var(--text-color);
        margin-bottom: 5px;
        font-size: 0.875rem;
    }

    .form-control {
        border-radius: var(--border-radius);
        border: 1px solid var(--border-color);
        padding: 8px 12px;
        font-size: 0.875rem;
    }

    .form-control:focus {
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(var(--primary-color), 0.2);
    }

    .btn-primary {
        background: var(--gradient-primary);
        border: none;
        color: var(--btn-text);
        padding: 8px 16px;
        border-radius: var(--border-radius);
        font-weight: 500;
        transition: all 0.2s;
    }

    .btn-primary:hover {
        background: var(--gradient-primary-75);
        transform: translateY(-1px);
    }

    .coordinates-display {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: rgba(0, 0, 0, 0.8);
        color: var(--btn-text);
        padding: 8px 15px;
        border-radius: var(--border-radius);
        font-size: 12px;
        z-index: 1000;
    }

    .table-preview {
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        overflow: hidden;
    }

    .table {
        margin-bottom: 0;
    }

    .table th {
        background: var(--gradient-primary-25);
        color: var(--text-color);
        font-weight: 600;
    }

    .table td, .table th {
        padding: 8px 12px;
        font-size: 0.875rem;
    }

    /* PDF Controls styling */
    .pdf-controls {
        background-color: var(--bg-dark);
        color: var(--btn-text);
        padding: 15px 25px;
        border-radius: 0 0 var(--border-radius) var(--border-radius);
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: -1px;
        flex-wrap: wrap;
        gap: 10px;
    }

    .controls-group {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .page-info {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .page-input {
        width: 40px;
        text-align: center;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--btn-text);
        border-radius: 4px;
        padding: 2px 5px;
    }

    .pdf-controls button {
        background: none;
        border: none;
        color: var(--btn-text);
        cursor: pointer;
        padding: 0 12px;
        opacity: 0.8;
        transition: opacity 0.2s;
    }

    .pdf-controls button:hover:not(:disabled) {
        opacity: 1;
        color: var(--primary-color);
    }

    .pdf-controls button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .zoom-controls {
        display: flex;
        align-items: center;
        margin-left: 25px;
        border-left: 1px solid rgba(255, 255, 255, 0.2);
        padding-left: 25px;
    }

    .zoom-level {
        margin: 0 12px;
        min-width: 60px;
        text-align: center;
    }

    /* Selection box styling */
    .selection-box {
        position: absolute;
        border: 2px solid var(--primary-color);
        background-color: var(--field-highlight-bg);
        pointer-events: none;
        z-index: 1000;
    }
    
    /* Line selection styles */
    .pdf-canvas-container.vertical-line-mode {
        cursor: col-resize;
    }
    
    .pdf-canvas-container.horizontal-line-mode {
        cursor: row-resize;
    }
    
    .pdf-canvas-container.rectangle-mode {
        cursor: crosshair;
    }
    
    .guide-line {
        position: absolute;
        z-index: 999;
        pointer-events: none;
    }
    
    .guide-line.vertical {
        width: 2px;
        background-color: rgba(255, 163, 29, 0.8);
    }
    
    .guide-line.horizontal {
        height: 2px;
        background-color: rgba(255, 163, 29, 0.8);
    }
    
    .guide-line.temporary {
        opacity: 0.5;
    }
    
    .guide-line.permanent {
        opacity: 0.8;
    }
    
    .guide-line-label {
        position: absolute;
        background-color: var(--primary-color);
        color: white;
        font-size: 10px;
        padding: 2px 4px;
        border-radius: 2px;
        white-space: nowrap;
    }
    
    .vertical-line-label {
        top: 5px;
        transform: translateX(-50%);
    }
    
    .horizontal-line-label {
        left: 5px;
        transform: translateY(-50%);
    }
    
    .selection-mode-controls .btn.active {
        background-color: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
    }

    /* Table Tool Styles */
    .table-grid {
        position: absolute;
        border: 2px solid rgba(66, 153, 225, 0.8);
        background-color: rgba(66, 153, 225, 0.08);
        z-index: 100;
        pointer-events: none;
        border-radius: 4px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
    }

    .table-cell {
        position: absolute;
        border: 1px solid rgba(66, 153, 225, 0.6);
        background-color: transparent;
        pointer-events: none;
    }

    .table-handle {
        position: absolute;
        width: 16px;
        height: 16px;
        background-color: white;
        border: 2px solid rgba(66, 153, 225, 0.9);
        border-radius: 50%;
        cursor: move;
        z-index: 101;
        pointer-events: auto;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .table-handle:hover {
        transform: scale(1.2);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    }

    .table-row-handle {
        position: absolute;
        width: 14px;
        height: 14px;
        background-color: white;
        border: 2px solid rgba(240, 82, 82, 0.9);
        border-radius: 50%;
        cursor: row-resize;
        z-index: 101;
        pointer-events: auto;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .table-row-handle:hover {
        transform: scale(1.2);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.25);
    }

    .table-col-handle {
        position: absolute;
        width: 14px;
        height: 14px;
        background-color: white;
        border: 2px solid rgba(72, 187, 120, 0.9);
        border-radius: 50%;
        cursor: col-resize;
        z-index: 101;
        pointer-events: auto;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .table-col-handle:hover {
        transform: scale(1.2);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.25);
    }

    .table-resize-handle {
        position: absolute;
        width: 16px;
        height: 16px;
        background-color: white;
        border: 2px solid rgba(79, 70, 229, 0.9);
        border-radius: 50%;
        cursor: nwse-resize;
        right: -8px;
        bottom: -8px;
        z-index: 102;
        pointer-events: auto;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .table-resize-handle:hover {
        transform: scale(1.2);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    }

    .table-container {
        position: absolute;
        z-index: 100;
        transform-origin: top left;
        will-change: transform;
    }

    .table-toolbar {
        position: absolute;
        top: -70px;
        left: 0;
        background-color: rgba(55, 65, 81, 0.92);
        border-radius: 12px;
        padding: 10px 12px;
        display: flex;
        gap: 8px;
        z-index: 103;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.25);
        min-width: 280px;
        justify-content: space-between;
        backdrop-filter: blur(4px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        animation: slideDown 0.3s ease-out;
    }

    .table-toolbar button {
        background: var(--gradient-primary);
        border: none;
        border-radius: 8px;
        padding: 5px 12px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        pointer-events: auto;
        color: white;
        flex: 1;
        white-space: nowrap;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .table-toolbar button:hover {
        background: var(--gradient-primary-75);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }

    .table-toolbar button:active {
        transform: translateY(0);
    }

    .table-row-handle {
        position: absolute;
        width: 14px;
        height: 14px;
        background-color: white;
        border: 2px solid rgba(240, 82, 82, 0.9);
        border-radius: 50%;
        cursor: row-resize;
        z-index: 101;
        pointer-events: auto;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .table-row-handle:hover {
        transform: scale(1.2);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.25);
    }

    .table-col-handle {
        position: absolute;
        width: 14px;
        height: 14px;
        background-color: white;
        border: 2px solid rgba(72, 187, 120, 0.9);
        border-radius: 50%;
        cursor: col-resize;
        z-index: 101;
        pointer-events: auto;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .table-col-handle:hover {
        transform: scale(1.2);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.25);
    }

    .table-resize-handle {
        position: absolute;
        width: 16px;
        height: 16px;
        background-color: white;
        border: 2px solid rgba(79, 70, 229, 0.9);
        border-radius: 50%;
        cursor: nwse-resize;
        right: -8px;
        bottom: -8px;
        z-index: 102;
        pointer-events: auto;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .table-resize-handle:hover {
        transform: scale(1.2);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    }

    .table-handle {
        position: absolute;
        width: 16px;
        height: 16px;
        background-color: white;
        border: 2px solid rgba(66, 153, 225, 0.9);
        border-radius: 50%;
        cursor: move;
        z-index: 101;
        pointer-events: auto;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .table-handle:hover {
        transform: scale(1.2);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    }

    .table-grid {
        position: absolute;
        border: 2px solid rgba(66, 153, 225, 0.8);
        background-color: rgba(66, 153, 225, 0.08);
        z-index: 100;
        pointer-events: none;
        border-radius: 4px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        animation: fadeIn 0.3s ease-out;
        transition: all 0.2s ease;
    }

    .table-cell {
        position: absolute;
        border: 1px solid rgba(66, 153, 225, 0.6);
        background-color: transparent;
        pointer-events: none;
        transition: all 0.2s ease;
    }

    /* Table action feedback */
    .table-action-success {
        animation: pulse 0.4s ease-in-out;
    }
    
    /* Add loader animation for when table is being processed */
    .table-processing {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: var(--primary-color);
        font-size: 1.5rem;
        z-index: 200;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 15px 25px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        gap: 10px;
        animation: fadeIn 0.3s ease-out;
    }
    
    .spinner {
        border: 3px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top: 3px solid var(--primary-color);
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Guide Line Styles */
    /* ... existing code ... */
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-3">
    <!-- Add CSRF Token input -->
    {% csrf_token %}
    
    <!-- Message container for notifications -->
    <div id="message-container" class="position-fixed top-0 end-0 p-3" style="z-index: 1050;"></div>
    
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center mb-3">
        <div class="page-header-simple d-flex align-items-center">
            <i class="fas fa-table me-2 text-primary"></i>
            <h5 class="mb-0">Table Extraction</h5>
        </div>
        <div>
            <button id="save-settings-btn" class="btn btn-primary me-2">
                <i class="fas fa-save me-1"></i> Save Settings
            </button>
            <a href="{% url 'pdf_app:template_list' %}" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left me-1"></i> Back
            </a>
        </div>
    </div>

    <!-- Field and Project Info -->
    {% if field_name or project_config %}
    <div class="alert alert-info mb-3">
        <div class="d-flex align-items-center">
            <i class="fas fa-info-circle me-2"></i>
            <div>
                {% if field_name %}
                <strong>Field:</strong> {{ field_name }}
                {% endif %}
                {% if project_config %}
                {% if field_name %} | {% endif %}
                <strong>Project Configuration:</strong> {{ project_config }}
                {% endif %}
            </div>
        </div>
    </div>
    {% endif %}

    <!-- Hidden fields to store field name and project config -->
    <input type="hidden" id="field_name" value="{{ field_name }}">
    <input type="hidden" id="project_config" value="{{ project_config }}">

    <!-- Settings Panel -->
    <div class="settings-panel mb-4">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h6 class="m-0"><i class="fas fa-cogs me-2"></i>Table Extraction Settings</h6>
        </div>
        
        <form id="settings-form">
            <div class="settings-grid">
                <!-- Row 1 -->
                <div class="setting-group">
                    <label for="strategy" class="setting-label">Overall Strategy</label>
                    <select id="strategy" name="strategy" class="setting-input">
                        <option value="lines">Lines</option>
                        <option value="lines_strict">Lines Strict</option>
                        <option value="text">Text</option>
                    </select>
                </div>
                
                <div class="setting-group">
                    <label for="vertical_strategy" class="setting-label">Vertical Strategy</label>
                    <select id="vertical_strategy" name="vertical_strategy" class="setting-input">
                        <option value="lines">Lines</option>
                        <option value="lines_strict">Lines Strict</option>
                        <option value="text">Text</option>
                    </select>
                </div>
                
                <div class="setting-group">
                    <label for="horizontal_strategy" class="setting-label">Horizontal Strategy</label>
                    <select id="horizontal_strategy" name="horizontal_strategy" class="setting-input">
                        <option value="lines">Lines</option>
                        <option value="lines_strict">Lines Strict</option>
                        <option value="text">Text</option>
                    </select>
                </div>
                
                <div class="setting-group">
                    <label for="snap_tolerance" class="setting-label">Snap Tolerance</label>
                    <input type="number" id="snap_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <div class="setting-group">
                    <label for="snap_x_tolerance" class="setting-label">Snap X Tolerance</label>
                    <input type="number" id="snap_x_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <div class="setting-group">
                    <label for="snap_y_tolerance" class="setting-label">Snap Y Tolerance</label>
                    <input type="number" id="snap_y_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <div class="setting-group">
                    <label for="join_tolerance" class="setting-label">Join Tolerance</label>
                    <input type="number" id="join_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <!-- Row 2 -->
                <div class="setting-group">
                    <label for="join_x_tolerance" class="setting-label">Join X Tolerance</label>
                    <input type="number" id="join_x_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <div class="setting-group">
                    <label for="join_y_tolerance" class="setting-label">Join Y Tolerance</label>
                    <input type="number" id="join_y_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <div class="setting-group">
                    <label for="edge_min_length" class="setting-label">Edge Min Length</label>
                    <input type="number" id="edge_min_length" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <div class="setting-group">
                    <label for="min_words_vertical" class="setting-label">Min Words Vertical</label>
                    <input type="number" id="min_words_vertical" class="setting-input" value="3" step="1">
                </div>
                
                <div class="setting-group">
                    <label for="min_words_horizontal" class="setting-label">Min Words Horizontal</label>
                    <input type="number" id="min_words_horizontal" class="setting-input" value="1" step="1">
                </div>
                
                <div class="setting-group">
                    <label for="intersection_tolerance" class="setting-label">Intersection Tolerance</label>
                    <input type="number" id="intersection_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <div class="setting-group">
                    <label for="intersection_x_tolerance" class="setting-label">Intersection X</label>
                    <input type="number" id="intersection_x_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <!-- Row 3 -->
                <div class="setting-group">
                    <label for="intersection_y_tolerance" class="setting-label">Intersection Y</label>
                    <input type="number" id="intersection_y_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <div class="setting-group">
                    <label for="text_tolerance" class="setting-label">Text Tolerance</label>
                    <input type="number" id="text_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <div class="setting-group">
                    <label for="text_x_tolerance" class="setting-label">Text X Tolerance</label>
                    <input type="number" id="text_x_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
                
                <div class="setting-group">
                    <label for="text_y_tolerance" class="setting-label">Text Y Tolerance</label>
                    <input type="number" id="text_y_tolerance" class="setting-input" value="3.0" step="0.1">
                </div>
            </div>
            
            <!-- Advanced Line Settings -->
            <div class="mt-4">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h6 class="m-0"><i class="fas fa-vector-square me-2"></i>Add lines</h6>
                </div>
                
                <div class="advanced-settings-row">
                    <div class="adv-setting-group" style="display: none;">
                        <label for="vertical_lines" class="setting-label">Vertical Lines</label>
                        <textarea id="vertical_lines" class="setting-textarea" placeholder="[x1, x2, ...]"></textarea>
                        <small class="setting-help">Enter x-coordinates as JSON array</small>
                        <div class="d-flex justify-content-between mt-2">
                            <button type="button" id="clear-vertical-lines-btn" class="btn btn-sm btn-outline-danger">
                                <i class="fas fa-trash-alt me-1"></i> Clear
                            </button>
                            <button type="button" id="vertical-line-mode-btn-section" class="btn btn-sm btn-outline-primary">
                                <i class="fas fa-grip-lines-vertical me-1"></i> Vertical Lines
                            </button>
                        </div>
                    </div>
                    
                    <div class="adv-setting-group" style="display: none;">
                        <label for="horizontal_lines" class="setting-label">Horizontal Lines</label>
                        <textarea id="horizontal_lines" class="setting-textarea" placeholder="[y1, y2, ...]"></textarea>
                        <small class="setting-help">Enter y-coordinates as JSON array</small>
                        <div class="d-flex justify-content-between mt-2">
                            <button type="button" id="clear-horizontal-lines-btn" class="btn btn-sm btn-outline-danger">
                                <i class="fas fa-trash-alt me-1"></i> Clear
                            </button>
                            <button type="button" id="horizontal-line-mode-btn-section" class="btn btn-sm btn-outline-primary">
                                <i class="fas fa-grip-lines me-1"></i> Horizontal Lines
                            </button>
                        </div>
                    </div>
                    
                    <div class="adv-setting-group">
                        <label for="add_lines" class="setting-label">points details in extract table</label>
                        <textarea id="add_lines" class="setting-textarea" placeholder='[[[x1, y1], [x2, y2]], ...]'></textarea>
                        <small class="setting-help">Defines virtual lines for table detection. Format: list of line segments, each with two points.</small>
                        <div class="d-flex justify-content-between mt-2">
                            <button type="button" id="clear-add-lines-btn" class="btn btn-sm btn-outline-danger">
                                <i class="fas fa-trash-alt me-1"></i> Clear
                            </button>
                            <div>
                                <button type="button" id="rectangle-mode-btn-section" class="btn btn-sm btn-outline-primary">
                                    <i class="fas fa-vector-square me-1"></i> Create Rectangle
                                </button>
                                <button id="createTableBtn" class="btn btn-sm btn-success ms-2" type="button">
                                    <i class="fas fa-table me-1"></i> Create Table
                                </button>
                                <button id="clearTableLinesBtn" class="btn btn-sm btn-danger ms-2" type="button">
                                    <i class="fas fa-trash-alt me-1"></i> Clear Table
                                </button>
                                <button id="applyTableChangesBtn" class="btn btn-sm btn-primary ms-2" style="display: none;" type="button">
                                    <i class="fas fa-check me-1"></i> Apply Changes
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </form>
    </div>

    <!-- Hidden table parameters -->
    <div id="tableCreationControls" style="display: none;">
        <input type="hidden" id="tableRows" value="1">
        <input type="hidden" id="tableColumns" value="2">
        <input type="hidden" id="cellWidth" value="50">
        <input type="hidden" id="cellHeight" value="20">
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Left Panel - PDF Viewer -->
        <div class="left-panel">
            <div class="pdf-preview-container">
                <div class="pdf-canvas-container" style="cursor: crosshair;">
                    <div class="pdf-content">
                        <div class="pdf-canvas-wrapper">
                            <canvas id="pdf-canvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- PDF Controls -->
            <div class="pdf-controls d-none" id="pdf-controls">
                <div class="controls-group">
                    <button id="prev-page" disabled><i class="fas fa-chevron-left"></i></button>
                    <div class="page-info">
                        Page <input type="number" class="page-input" id="page-input" min="1" value="1"> of <span id="total-pages">1</span>
                    </div>
                    <button id="next-page"><i class="fas fa-chevron-right"></i></button>
                </div>

                <div class="controls-group">
                    <button id="rotate-ccw" title="Rotate Counter-Clockwise"><i class="fas fa-undo"></i></button>
                    <button id="rotate-cw" title="Rotate Clockwise"><i class="fas fa-redo"></i></button>
                </div>

                <div class="page-dimensions" id="page-dimensions">
                    Page Size: <span id="page-width">0</span> x <span id="page-height">0</span> px
                </div>
                
                <div class="zoom-controls">
                    <button id="zoom-out" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
                    <input type="text" id="zoom-level" class="zoom-level" value="100%">
                    <button id="zoom-in" title="Zoom In"><i class="fas fa-search-plus"></i></button>
                    <button id="zoom-reset" title="Reset Zoom"><i class="fas fa-sync-alt"></i></button>
                </div>
            </div>
        </div>

        <!-- Right Panel - Table Preview -->
        <div class="right-panel">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h6 class="mb-0"><i class="fas fa-table me-2"></i>Extracted Tables</h6>
                <button id="extract-table-btn" class="btn btn-primary btn-sm">
                    <i class="fas fa-sync-alt me-1"></i> Extract Table
                </button>
            </div>
            <div class="table-preview-container" id="table-preview">
                <div class="text-center text-muted p-4">
                    <i class="fas fa-info-circle mb-2 d-block" style="font-size: 2rem;"></i>
                    Select an area on the PDF and click "Extract Table" to begin
                </div>
            </div>
        </div>
    </div>

    <!-- Coordinates Display -->
    <div class="coordinates-display" id="coordinates-display">X: 0, Y: 0</div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
<script>
    // Set PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    // Initialize variables
    let pdfDoc = null;
    let currentPage = 1;
    let currentScale = 1.0;
    let currentRotation = 0;
    let isSelectionMode = true;
    let isDrawing = false;
    let startX, startY;
    let currentSelectionBox = null;
    let originalPdfWidth = 0;
    let originalPdfHeight = 0;

    // Global arrays for guide lines
    window.verticalGuideLines = [];
    window.horizontalGuideLines = [];
    window.rectangleGuideLines = [];
    window.currentSelectionMode = 'table'; // Set table as default mode

    // Global function to update add_lines textarea
    function updateAddLinesTextarea() {
        const textarea = document.getElementById('add_lines');
        if (textarea) {
            // Format the rectangleGuideLines array for PyMuPDF add_lines parameter
            // Format should be [[[x1, y1], [x2, y2]], ...] - a list of line segments
            if (window.rectangleGuideLines && window.rectangleGuideLines.length > 0) {
                textarea.value = JSON.stringify(window.rectangleGuideLines);
                console.log('Updated add_lines textarea with rectangle lines:', window.rectangleGuideLines);
                
                // Force the change event to ensure other scripts know the textarea was updated
                const event = new Event('change', { bubbles: true });
                textarea.dispatchEvent(event);
            } else {
                // If no rectangle lines, set empty array
                textarea.value = '[]';
                console.log('No rectangle lines found, set empty array in add_lines textarea');
            }
        } else {
            console.warn('add_lines textarea element not found');
        }
    }

    // Global function to add a rectangle defined by two points
    function addRectangle(startX, startY, endX, endY) {
        console.log(`Adding rectangle from (${startX}, ${startY}) to (${endX}, ${endY})`);
        
        try {
            // Convert screen coordinates to PDF coordinates
            const startPdf = convertCoordinates(startX, startY, 0, 0, 'toPdf');
            const endPdf = convertCoordinates(endX, endY, 0, 0, 'toPdf');
            
            console.log(`PDF coordinates: from (${startPdf.x}, ${startPdf.y}) to (${endPdf.x}, ${endPdf.y})`);
            
            // Create the four lines of the rectangle (top, right, bottom, left)
            // Format for PyMuPDF add_lines: [[[x1, y1], [x2, y2]], ...] - list of line segments
            const rectangleLines = [
                [[startPdf.x, startPdf.y], [endPdf.x, startPdf.y]], // Top
                [[endPdf.x, startPdf.y], [endPdf.x, endPdf.y]],     // Right
                [[endPdf.x, endPdf.y], [startPdf.x, endPdf.y]],     // Bottom
                [[startPdf.x, endPdf.y], [startPdf.x, startPdf.y]]  // Left
            ];
            
            // Add to array
            if (!window.rectangleGuideLines) {
                window.rectangleGuideLines = [];
            }
            window.rectangleGuideLines = window.rectangleGuideLines.concat(rectangleLines);
            
            // Log the added lines for debugging
            console.log('Rectangle coordinates added:');
            rectangleLines.forEach((line, index) => {
                console.log(`Line ${index+1}: from (${line[0][0]}, ${line[0][1]}) to (${line[1][0]}, ${line[1][1]})`);
            });
            
            // Update textarea
            updateAddLinesTextarea();
            
            showMessage(`Added rectangle with 4 lines`, 'success');
            return true;
        } catch (error) {
            console.error('Error creating rectangle:', error);
            showMessage(`Error creating rectangle: ${error.message}`, 'error');
            return false;
        }
    }

    // Function to convert between screen and PDF coordinates
    function convertCoordinates(coords, direction = 'toPdf') {
        // Handle different parameter formats
        let x, y, width, height;
        
        if (typeof coords === 'object' && coords !== null) {
            // Object format: {x, y, width, height}
            x = coords.x;
            y = coords.y;
            width = coords.width;
            height = coords.height;
        } else {
            // Individual parameters format
            x = coords;
            y = arguments[1];
            width = arguments[2];
            height = arguments[3];
            direction = arguments[4] || 'toPdf';
        }

        if (!window.currentPageObj) {
            return { x, y, width, height };
        }
        
        // Get the viewport at scale 1.0 (original PDF size)
        const originalViewport = window.currentPageObj.getViewport({ scale: 1.0, rotation: 0 });
        const pdfCanvas = document.getElementById('pdf-canvas');
        const canvasRect = pdfCanvas.getBoundingClientRect();
        
        if (direction === 'toPdf') {
            // Screen to PDF conversion
            const scaleX = originalViewport.width / canvasRect.width;
            const scaleY = originalViewport.height / canvasRect.height;
            
            // Convert screen coordinates to PDF coordinates
            let pdfX = Math.round(x * scaleX);
            let pdfY = Math.round(y * scaleY);
            const pdfWidth = Math.round(width * scaleX);
            const pdfHeight = Math.round(height * scaleY);
            
            // Ensure coordinates are non-negative
            pdfX = Math.max(0, pdfX);
            pdfY = Math.max(0, pdfY);
            
            return { x: pdfX, y: pdfY, width: pdfWidth, height: pdfHeight };
        } else {
            // PDF to screen conversion
            const scaleX = canvasRect.width / originalViewport.width;
            const scaleY = canvasRect.height / originalViewport.height;
            
            // Convert PDF coordinates to screen coordinates
            const screenX = Math.round(x * scaleX);
            const screenY = Math.round(y * scaleY);
            const screenWidth = Math.round(width * scaleX);
            const screenHeight = Math.round(height * scaleY);
            
            return { x: screenX, y: screenY, width: screenWidth, height: screenHeight };
        }
    }

    // Get PDF URL from context
    const pdfUrl = "{{ pdf_document.file.url }}";
    const pdfName = "{{ pdf_name }}";
    const pdfDocumentId = "{{ pdf_document.id }}";

    // Global function to convert screen coordinates to PDF coordinates
    function convertScreenToPdfCoordinate(x, y) {
        if (!window.currentPageObj) return { x, y };
        
        const originalViewport = window.currentPageObj.getViewport({ scale: 1.0, rotation: 0 });
        const canvas = document.getElementById('pdf-canvas');
        
        if (!canvas) return { x, y };
        
        const scaleX = originalViewport.width / canvas.width;
        const scaleY = originalViewport.height / canvas.height;
        
        // Apply rotation if needed
        let pdfX, pdfY;
        
        if (currentRotation === 0) {
            pdfX = x * scaleX;
            pdfY = y * scaleY;
        } else if (currentRotation === 90) {
            pdfX = y * scaleX;
            pdfY = originalViewport.height - (x * scaleY);
        } else if (currentRotation === 180) {
            pdfX = originalViewport.width - (x * scaleX);
            pdfY = originalViewport.height - (y * scaleY);
        } else if (currentRotation === 270) {
            pdfX = originalViewport.width - (y * scaleX);
            pdfY = x * scaleY;
        }
        
        return {
            x: Math.round(pdfX),
            y: Math.round(pdfY)
        };
    }

    function initializeLineSelectionModes() {
        // Mode buttons - we've removed them from the UI, but we'll keep references for functionality
        const normalModeBtn = null; // Was document.getElementById('normal-mode-btn')
        const verticalLineModeBtn = null; // Was document.getElementById('vertical-line-mode-btn')
        const horizontalLineModeBtn = null; // Was document.getElementById('horizontal-line-mode-btn')
        const rectangleModeBtn = null; // Was document.getElementById('rectangle-mode-btn')
        
        // Clear buttons
        const clearVerticalLinesBtn = document.getElementById('clear-vertical-lines-btn');
        const clearHorizontalLinesBtn = document.getElementById('clear-horizontal-lines-btn');
        const clearAddLinesBtn = document.getElementById('clear-add-lines-btn');
        
        // Add buttons
        const addVerticalLineBtn = document.getElementById('vertical-line-mode-btn-section');
        const addHorizontalLineBtn = document.getElementById('horizontal-line-mode-btn-section');
        const addRectangleBtn = document.getElementById('rectangle-mode-btn-section');
        
        // Canvas container
        const canvasContainer = document.querySelector('.pdf-canvas-container');
        
        // Temporary guide line for preview
        let temporaryGuideLine = null;
        
        // Set selection mode
        function setSelectionMode(mode) {
            // Remove all mode classes
            canvasContainer.classList.remove('vertical-line-mode', 'horizontal-line-mode', 'rectangle-mode');
            
            // Set current mode
            window.currentSelectionMode = mode;
            
            // Add appropriate class
            switch(mode) {
                case 'vertical-line':
                    canvasContainer.classList.add('vertical-line-mode');
                    break;
                case 'horizontal-line':
                    canvasContainer.classList.add('horizontal-line-mode');
                    break;
                case 'rectangle':
                    canvasContainer.classList.add('rectangle-mode');
                    break;
            }
        }
        
        // Clear guide lines
        function clearGuideLines(type) {
            const container = document.querySelector('.pdf-canvas-wrapper');
            
            if (type === 'vertical' || type === 'all') {
                // Remove vertical guide lines from DOM
                document.querySelectorAll('.guide-line.vertical.permanent').forEach(line => line.remove());
                window.verticalGuideLines = [];
                updateVerticalLinesTextarea();
            }
            
            if (type === 'horizontal' || type === 'all') {
                // Remove horizontal guide lines from DOM
                document.querySelectorAll('.guide-line.horizontal.permanent').forEach(line => line.remove());
                window.horizontalGuideLines = [];
                updateHorizontalLinesTextarea();
            }
            
            if (type === 'rectangle' || type === 'all') {
                // Remove rectangle guide lines from DOM
                document.querySelectorAll('.rectangle-guide').forEach(rect => rect.remove());
                // Clear the array
                window.rectangleGuideLines = [];
                // Update the textarea
                updateAddLinesTextarea();
                console.log('Cleared rectangle guide lines');
            }
        }
        
        // Add event listeners to clear buttons
        clearVerticalLinesBtn.addEventListener('click', () => clearGuideLines('vertical'));
        clearHorizontalLinesBtn.addEventListener('click', () => clearGuideLines('horizontal'));
        clearAddLinesBtn.addEventListener('click', () => {
            clearGuideLines('rectangle');
            console.log('Rectangle lines cleared by user');
            showMessage('Rectangle lines cleared', 'info');
        });
        
        // Update textareas with guide line coordinates
        function updateVerticalLinesTextarea() {
            const textarea = document.getElementById('vertical_lines');
            if (textarea) {
                textarea.value = JSON.stringify(window.verticalGuideLines);
            }
        }
        
        function updateHorizontalLinesTextarea() {
            const textarea = document.getElementById('horizontal_lines');
            if (textarea) {
                textarea.value = JSON.stringify(window.horizontalGuideLines);
            }
        }
        
        // Global function to create a guide line element
        function createGuideLine(type, position, isPermanent = false) {
            const container = document.querySelector('.pdf-canvas-wrapper');
            const canvas = document.getElementById('pdf-canvas');
            
            if (!container || !canvas) return null;
            
            // Get the canvas position relative to the wrapper
            const canvasRect = canvas.getBoundingClientRect();
            const wrapperRect = container.getBoundingClientRect();
            const canvasOffsetLeft = canvasRect.left - wrapperRect.left;
            const canvasOffsetTop = canvasRect.top - wrapperRect.top;
            
            const guideLine = document.createElement('div');
            guideLine.className = `guide-line ${type} ${isPermanent ? 'permanent' : 'temporary'}`;
            
            const label = document.createElement('div');
            label.className = `guide-line-label ${type}-line-label`;
            
            if (type === 'vertical') {
                // Position relative to the canvas, not the wrapper
                guideLine.style.left = `${canvasOffsetLeft + position}px`;
                // Start from the top of the canvas and extend only to the canvas height
                guideLine.style.top = `${canvasOffsetTop}px`;
                guideLine.style.height = `${canvasRect.height}px`;
                
                // Use the global conversion function
                const pdfX = convertCoordinates(position, 0, 0, 0).x;
                label.textContent = `x: ${Math.round(pdfX)}`;
                guideLine.appendChild(label);
            } else if (type === 'horizontal') {
                // Position relative to the canvas, not the wrapper
                guideLine.style.top = `${canvasOffsetTop + position}px`;
                // Start from the left of the canvas and extend only to the canvas width
                guideLine.style.left = `${canvasOffsetLeft}px`;
                guideLine.style.width = `${canvasRect.width}px`;
                
                // Use the global conversion function
                const pdfY = convertCoordinates(0, position, 0, 0).y;
                label.textContent = `y: ${Math.round(pdfY)}`;
                guideLine.appendChild(label);
            }
            
            container.appendChild(guideLine);
            return guideLine;
        }
        
        // Add a vertical line at the given screen x-coordinate
        function addVerticalLine(screenX) {
            const canvas = document.getElementById('pdf-canvas');
            
            // Ensure the line is within the canvas bounds
            if (screenX < 0 || screenX > canvas.width) {
                showMessage('Vertical line must be within the PDF boundaries', 'warning');
                return;
            }
            
            const pdfX = convertCoordinates(screenX, 0, 0, 0).x;
            
            // Check if this line already exists
            if (window.verticalGuideLines.includes(pdfX)) {
                return;
            }
            
            // Add to array and update textarea
            window.verticalGuideLines.push(pdfX);
            window.verticalGuideLines.sort((a, b) => a - b); // Sort numerically
            updateVerticalLinesTextarea();
            
            // Create permanent guide line
            createGuideLine('vertical', screenX, true);
            
            showMessage(`Added vertical line at x: ${pdfX}`, 'success');
        }
        
        // Add a horizontal line at the given screen y-coordinate
        function addHorizontalLine(screenY) {
            const canvas = document.getElementById('pdf-canvas');
            
            // Ensure the line is within the canvas bounds
            if (screenY < 0 || screenY > canvas.height) {
                showMessage('Horizontal line must be within the PDF boundaries', 'warning');
                return;
            }
            
            const pdfY = convertCoordinates(0, screenY, 0, 0).y;
            
            // Check if this line already exists
            if (window.horizontalGuideLines.includes(pdfY)) {
                return;
            }
            
            // Add to array and update textarea
            window.horizontalGuideLines.push(pdfY);
            window.horizontalGuideLines.sort((a, b) => a - b); // Sort numerically
            updateHorizontalLinesTextarea();
            
            // Create permanent guide line
            createGuideLine('horizontal', screenY, true);
            
            showMessage(`Added horizontal line at y: ${pdfY}`, 'success');
        }
        
        // Add event listeners for manual line addition
        addVerticalLineBtn.addEventListener('click', () => {
            // Set mode to vertical line selection
            setSelectionMode('vertical-line');
            showMessage('Click on the PDF to add vertical lines', 'info');
        });
        
        addHorizontalLineBtn.addEventListener('click', () => {
            // Set mode to horizontal line selection
            setSelectionMode('horizontal-line');
            showMessage('Click on the PDF to add horizontal lines', 'info');
        });
        
        addRectangleBtn.addEventListener('click', () => {
            // Don't change mode if table creation is in progress
            if (isCreatingTable) {
                console.log('Ignoring rectangle mode change during table creation');
                return;
            }
            
            // Set mode to rectangle selection
            setSelectionMode('rectangle');
            console.log('Rectangle mode activated - click and drag to create a rectangle');
            showMessage('Click and drag on the PDF to add a rectangle', 'info');
        });

        // Original manual input functions are removed

        // Modify the existing selection handlers to work with the new modes
        const originalMouseDown = canvasContainer.onmousedown;
        const originalMouseMove = document.onmousemove;
        const originalMouseUp = document.onmouseup;
        
        // Override the canvas container's mouse events
        canvasContainer.addEventListener('mousemove', function(e) {
            if (window.currentSelectionMode === 'normal') {
                return;
            }
            
            const canvas = document.getElementById('pdf-canvas');
            const rect = canvas.getBoundingClientRect();
            
            // Remove any temporary guide line
            if (temporaryGuideLine) {
                temporaryGuideLine.remove();
                temporaryGuideLine = null;
            }
            
            // Check if mouse is within canvas bounds
            if (e.clientX < rect.left || e.clientX > rect.right || 
                e.clientY < rect.top || e.clientY > rect.bottom) {
                return;
            }
            
            // Calculate position relative to canvas
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Create temporary guide line based on mode
            if (window.currentSelectionMode === 'vertical-line') {
                temporaryGuideLine = createGuideLine('vertical', x);
            } else if (window.currentSelectionMode === 'horizontal-line') {
                temporaryGuideLine = createGuideLine('horizontal', y);
            }
        });
        
        canvasContainer.addEventListener('click', function(e) {
            if (window.currentSelectionMode === 'normal' || window.currentSelectionMode === 'rectangle') {
                return;
            }
            
            const canvas = document.getElementById('pdf-canvas');
            const rect = canvas.getBoundingClientRect();
            
            // Check if click is within canvas bounds
            if (e.clientX < rect.left || e.clientX > rect.right || 
                e.clientY < rect.top || e.clientY > rect.bottom) {
                return;
            }
            
            // Calculate position relative to canvas
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Add guide line based on mode
            if (window.currentSelectionMode === 'vertical-line') {
                addVerticalLine(x);
            } else if (window.currentSelectionMode === 'horizontal-line') {
                addHorizontalLine(y);
            }
        });
    }

    function initializeSelectionHandlers() {
        const pdfCanvas = document.getElementById('pdf-canvas');
        const canvasContainer = document.querySelector('.pdf-canvas-container');

        // Mouse down - start drawing
        canvasContainer.addEventListener('mousedown', function(e) {
            // If in table mode and table creation is active, don't handle this event
            // This prevents conflict between table creation and selection drawing
            if (window.currentSelectionMode === 'table' && isCreatingTable) {
                return;
            }
            
            // If not in normal or rectangle mode, return
            if (window.currentSelectionMode !== 'normal' && window.currentSelectionMode !== 'rectangle') {
                return;
            }
            
            const rect = pdfCanvas.getBoundingClientRect();
            
            // Check if click is within canvas bounds
            if (e.clientX < rect.left || e.clientX > rect.right || 
                e.clientY < rect.top || e.clientY > rect.bottom) {
                return;
            }
            
            isDrawing = true;
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            
            console.log(`Mouse down at canvas coordinates: (${startX}, ${startY})`);
            
            // Remove any existing selection boxes
            document.querySelectorAll('.selection-box').forEach(box => box.remove());
            
            // Only clear selectedArea if in normal mode
            if (window.currentSelectionMode === 'normal') {
                window.selectedArea = null; // Clear previous selection
            }
            
            // Create new selection box
            currentSelectionBox = document.createElement('div');
            currentSelectionBox.className = 'selection-box';
            currentSelectionBox.style.position = 'absolute';
            currentSelectionBox.style.border = '2px solid var(--primary-color)';
            currentSelectionBox.style.backgroundColor = 'rgba(117, 207, 255, 0.1)';
            currentSelectionBox.style.pointerEvents = 'none';
            currentSelectionBox.style.zIndex = '1000';
            
            // Add to the canvas wrapper
            const wrapper = document.querySelector('.pdf-canvas-wrapper');
            if (wrapper) {
                wrapper.appendChild(currentSelectionBox);
                
                // Adjust position to be relative to the wrapper
                const wrapperRect = wrapper.getBoundingClientRect();
                const offsetX = rect.left - wrapperRect.left;
                const offsetY = rect.top - wrapperRect.top;
                
                currentSelectionBox.style.left = (startX + offsetX) + 'px';
                currentSelectionBox.style.top = (startY + offsetY) + 'px';
            }
        });

        // Mouse move - update selection box
        document.addEventListener('mousemove', function(e) {
            if (!isDrawing) return;
            
            // If not in normal or rectangle mode, return
            if (window.currentSelectionMode !== 'normal' && window.currentSelectionMode !== 'rectangle') {
                return;
            }
            
            const rect = pdfCanvas.getBoundingClientRect();
            const wrapper = document.querySelector('.pdf-canvas-wrapper');
            if (!wrapper || !currentSelectionBox) return;
            
            // Calculate current position relative to canvas
            const currentX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
            const currentY = Math.max(0, Math.min(e.clientY - rect.top, rect.height));
            
            // Calculate width and height
            const width = Math.abs(currentX - startX);
            const height = Math.abs(currentY - startY);
            
            // Calculate top-left corner
            const selectionX = Math.min(startX, currentX);
            const selectionY = Math.min(startY, currentY);
            
            // Adjust position to be relative to the wrapper
            const wrapperRect = wrapper.getBoundingClientRect();
            const offsetX = rect.left - wrapperRect.left;
            const offsetY = rect.top - wrapperRect.top;
            
            // Update selection box
            currentSelectionBox.style.left = (selectionX + offsetX) + 'px';
            currentSelectionBox.style.top = (selectionY + offsetY) + 'px';
            currentSelectionBox.style.width = width + 'px';
            currentSelectionBox.style.height = height + 'px';
            
            // Update coordinates display
            const coordsDisplay = document.getElementById('coordinates-display');
            if (coordsDisplay) {
                coordsDisplay.textContent = `X: ${Math.round(selectionX)}, Y: ${Math.round(selectionY)}, W: ${Math.round(width)}, H: ${Math.round(height)}`;
            }
        });

        // Mouse up - finish drawing
        document.addEventListener('mouseup', function() {
            // Skip if not drawing or if in table mode and creating a table
            if (!isDrawing || (window.currentSelectionMode === 'table' && isCreatingTable)) return;
            
            isDrawing = false;
            
            // Get the final selection coordinates
            if (currentSelectionBox) {
                const style = window.getComputedStyle(currentSelectionBox);
                const rect = pdfCanvas.getBoundingClientRect();
                
                // Get the wrapper for offset calculation
                const wrapper = document.querySelector('.pdf-canvas-wrapper');
                const wrapperRect = wrapper.getBoundingClientRect();
                
                // Calculate offsets
                const offsetX = rect.left - wrapperRect.left;
                const offsetY = rect.top - wrapperRect.top;
                
                // Get selection box position relative to canvas
                const selectionLeft = parseInt(style.left) - offsetX;
                const selectionTop = parseInt(style.top) - offsetY;
                const selectionWidth = parseInt(style.width);
                const selectionHeight = parseInt(style.height);
                
                console.log(`Selection completed: left=${selectionLeft}, top=${selectionTop}, width=${selectionWidth}, height=${selectionHeight}`);
                console.log(`Current selection mode: ${window.currentSelectionMode}`);
                
                // If in rectangle mode, add the rectangle
                if (window.currentSelectionMode === 'rectangle' && selectionWidth > 10 && selectionHeight > 10) {
                    console.log('Adding rectangle from selection to the additional lines');
                    try {
                        addRectangle(
                            selectionLeft, 
                            selectionTop, 
                            selectionLeft + selectionWidth, 
                            selectionTop + selectionHeight
                        );
                    } catch (error) {
                        console.error('Error adding rectangle:', error);
                        showMessage('Error adding rectangle: ' + error.message, 'error');
                    }
                    return;
                }
                
                // Convert screen coordinates to PDF coordinates using the conversion function
                const pdfCoords = convertCoordinates(
                    selectionLeft, 
                    selectionTop, 
                    selectionWidth, 
                    selectionHeight, 
                    'toPdf'
                );
                
                // Store coordinates for table extraction (only in normal mode)
                if (window.currentSelectionMode === 'normal') {
                    window.selectedArea = {
                        x: pdfCoords.x,
                        y: pdfCoords.y,
                        width: pdfCoords.width,
                        height: pdfCoords.height,
                        page: window.currentPage
                    };
                    
                    console.log('Selected area (PDF coordinates):', window.selectedArea);
                }
            }
        });
    }

    function extractTable() {
        const coords = window.selectedArea;
        const settings = getTableSettings();

        // Show loading state
        const tablePreview = document.getElementById('table-preview');
        tablePreview.innerHTML = `
            <div class="text-center p-4">
                <i class="fas fa-spinner fa-spin mb-2 d-block" style="font-size: 2rem; color: var(--primary-color);"></i>
                Extracting table...
            </div>
        `;

        // If no area is selected, use the entire page
        if (!coords && window.currentPageObj) {
            // Use the original PDF dimensions
            const fullPageCoords = {
                x: 0,
                y: 0,
                width: originalPdfWidth,
                height: originalPdfHeight,
                page: window.currentPage || 1,
                rotation: currentRotation
            };
            console.log('Using full page coordinates:', fullPageCoords);
            extractTableFromBackend(fullPageCoords.x, fullPageCoords.y, fullPageCoords.width, fullPageCoords.height, fullPageCoords.page, settings, fullPageCoords.rotation);
        } else if (coords) {
            // Add rotation to the coordinates
            const coordsWithRotation = {
                ...coords,
                rotation: currentRotation
            };
            console.log('Using selected area with rotation:', coordsWithRotation);
            extractTableFromBackend(coords.x, coords.y, coords.width, coords.height, coords.page, settings, currentRotation);
        } else {
            showMessage('Error: PDF not loaded properly', 'error');
        }
    }

    function getTableSettings() {
        // Define default values
        const defaults = {
            strategy: 'lines',
            vertical_strategy: 'lines',
            horizontal_strategy: 'lines',
            snap_tolerance: 3.0,
            snap_x_tolerance: 3.0,
            snap_y_tolerance: 3.0,
            join_tolerance: 3.0,
            join_x_tolerance: 3.0,
            join_y_tolerance: 3.0,
            edge_min_length: 3.0,
            min_words_vertical: 3,
            min_words_horizontal: 1,
            intersection_tolerance: 3.0,
            intersection_x_tolerance: 3.0,
            intersection_y_tolerance: 3.0,
            text_tolerance: 3.0,
            text_x_tolerance: 3.0,
            text_y_tolerance: 3.0
        };
        
        // Start with default values
        const settings = {...defaults};
        
        // Add debug output
        console.log("Starting to collect table settings");
        console.log("Default values:", defaults);
        
        // Override with form values if they exist
        const formElements = [
            'strategy', 'vertical_strategy', 'horizontal_strategy',
            'snap_tolerance', 'snap_x_tolerance', 'snap_y_tolerance',
            'join_tolerance', 'join_x_tolerance', 'join_y_tolerance',
            'edge_min_length', 'min_words_vertical', 'min_words_horizontal',
            'intersection_tolerance', 'intersection_x_tolerance', 'intersection_y_tolerance',
            'text_tolerance', 'text_x_tolerance', 'text_y_tolerance'
        ];
        
        formElements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                if (id.startsWith('strategy')) {
                    // Make sure strategy values are valid strings
                    console.log(`Reading strategy value for ${id}: "${element.value}"`);
                    if (element.value && element.value !== 'NaN' && element.value !== 'undefined') {
                        settings[id] = element.value;
                        console.log(`Using ${id} value: "${settings[id]}"`);
                    } else {
                        console.warn(`Invalid ${id} value: "${element.value}", using default: "${defaults[id]}"`);
                        // Keep the default value if the form value is invalid
                    }
                } else {
                    // Parse numeric values
                    console.log(`Reading numeric value for ${id}: "${element.value}"`);
                    const parsedValue = parseFloat(element.value);
                    if (!isNaN(parsedValue)) {
                        settings[id] = parsedValue;
                        console.log(`Using ${id} value: ${settings[id]}`);
                    } else {
                        console.warn(`Invalid ${id} value: "${element.value}", using default: ${defaults[id]}`);
                        // Keep the default value if the form value is invalid
                    }
                }
            } else {
                console.warn(`Element not found for ${id}, using default value`);
            }
        });
        
        // Parse JSON fields
        try {
            const verticalLines = document.getElementById('vertical_lines');
            if (verticalLines && verticalLines.value && verticalLines.value.trim()) {
                try {
                    settings.vertical_lines = JSON.parse(verticalLines.value);
                    console.log('Parsed vertical_lines:', settings.vertical_lines);
                } catch (err) {
                    console.error('Error parsing vertical_lines JSON:', err);
                }
            }
            
            const horizontalLines = document.getElementById('horizontal_lines');
            if (horizontalLines && horizontalLines.value && horizontalLines.value.trim()) {
                try {
                    settings.horizontal_lines = JSON.parse(horizontalLines.value);
                    console.log('Parsed horizontal_lines:', settings.horizontal_lines);
                } catch (err) {
                    console.error('Error parsing horizontal_lines JSON:', err);
                }
            }
            
            // Parse and validate add_lines (rectangle lines)
            const addLines = document.getElementById('add_lines');
            if (addLines && addLines.value && addLines.value.trim()) {
                try {
                    const addLinesData = JSON.parse(addLines.value);
                    // Validate the format of add_lines - each element should be array of two points
                    const isValidFormat = Array.isArray(addLinesData) && 
                        addLinesData.every(line => 
                            Array.isArray(line) && 
                            line.length === 2 && 
                            line.every(point => 
                                Array.isArray(point) && 
                                point.length === 2 && 
                                !isNaN(point[0]) && 
                                !isNaN(point[1])
                            )
                        );
                    
                    if (isValidFormat) {
                        settings.add_lines = addLinesData;
                        console.log('Valid add_lines format detected with', addLinesData.length, 'line segments');
                    } else {
                        console.warn('Invalid add_lines format. Expected [[[x1, y1], [x2, y2]], ...]');
                    }
                } catch (err) {
                    console.error('Error parsing add_lines JSON:', err);
                }
            } else {
                console.log('No add_lines data found in textarea');
            }
        } catch (error) {
            console.error('Error parsing line settings:', error);
            showMessage('Invalid JSON format in line settings. Please check your input.', 'error');
        }
        
        // Final validation to ensure strategy values are never NaN
        ['strategy', 'vertical_strategy', 'horizontal_strategy'].forEach(key => {
            console.log(`Final check for ${key}: "${settings[key]}"`);
            if (!settings[key] || settings[key] === 'NaN' || settings[key] === 'undefined') {
                settings[key] = defaults[key];
                console.log(`Applied default for ${key}: "${settings[key]}"`);
            }
        });
        
        console.log('Final table settings:', settings);
        return settings;
    }

    function getCurrentSelectionCoordinates() {
        // Return the current selection coordinates or null if no selection
        if (window.selectedArea) {
            return {
                ...window.selectedArea,
                rotation: currentRotation
            };
        }
        
        // If no selection but PDF is loaded, return full page coordinates
        if (window.currentPageObj) {
            return {
                x: 0,
                y: 0,
                width: originalPdfWidth,
                height: originalPdfHeight,
                page: window.currentPage || 1,
                rotation: currentRotation
            };
        }
        
        return null;
    }

    async function saveTableSettings() {
        const settings = getTableSettings();
        const coords = getCurrentSelectionCoordinates();
        
        // Get field name and project configuration from hidden fields
        const fieldName = document.getElementById('field_name').value;
        const projectConfig = document.getElementById('project_config').value;

        try {
            const response = await fetch('/pdf/api/save-table-settings/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: JSON.stringify({
                    settings: settings,
                    coordinates: coords,
                    field_name: fieldName,
                    project_config: projectConfig
                })
            });

            const data = await response.json();
            if (data.success) {
                showMessage('Settings saved successfully', 'success');
            } else {
                showMessage('Error saving settings: ' + data.error, 'error');
            }
        } catch (error) {
            showMessage('Error saving settings: ' + error.message, 'error');
        }
    }

    async function extractTableFromBackend(x, y, width, height, pageNumber, settings = null, rotation = 0) {
        try {
            // Create form data
            const formData = new FormData();
            formData.append('x', x);
            formData.append('y', y);
            formData.append('width', width);
            formData.append('height', height);
            formData.append('page_number', pageNumber);
            formData.append('rotation', rotation);
            
            // Add settings if provided
            if (settings) {
                console.log('Sending table extraction settings to backend:', settings);
                
                // Special handling for JSON array parameters
                const jsonArrayParams = ['add_lines', 'vertical_lines', 'horizontal_lines'];
                
                // Process each setting
                Object.entries(settings).forEach(([key, value]) => {
                    if (jsonArrayParams.includes(key) && value) {
                        // Convert array parameters to JSON strings
                        console.log(`Converting ${key} to JSON string:`, value);
                        formData.append(key, JSON.stringify(value));
                    } else {
                        // Add other settings normally
                        formData.append(key, value);
                    }
                });
                
                // Special debug for add_lines
                if (settings.add_lines) {
                    console.log(`add_lines parameter included with ${settings.add_lines.length} line segments`);
                    console.log('First few lines:', settings.add_lines.slice(0, 2));
                }
            }

            // Add PDF document ID to form data
            formData.append('pdf_document_id', pdfDocumentId);
            console.log('Using PDF Document ID:', pdfDocumentId);

            // Get CSRF token from the meta tag
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || 
                            document.querySelector('[name=csrfmiddlewaretoken]')?.value;
            
            if (!csrfToken) {
                throw new Error('CSRF token not found');
            }
            
            // Make the API request
            const response = await fetch('{% url "pdf_app:extract_table_from_coordinates" %}', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrfToken
                },
                body: formData
            });

            if (!response.ok) {
                throw new Error(`Server returned ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            
            // Update the table preview with the results
            const tablePreview = document.getElementById('table-preview');
            
            if (data.success && data.tables && data.tables.length > 0) {
                let tableHtml = '<div class="table-responsive">';
                
                data.tables.forEach((table, index) => {
                    tableHtml += `<h6 class="mt-3 mb-2">Table ${index + 1}</h6>`;
                    tableHtml += '<table class="table table-bordered table-sm">';
                    
                    // Add table rows and cells
                    table.cells.forEach((row, rowIndex) => {
                        tableHtml += '<tr>';
                        row.forEach((cell, cellIndex) => {
                            // Use th for header row
                            const cellTag = rowIndex === 0 ? 'th' : 'td';
                            tableHtml += `<${cellTag} class="small">${cell}</${cellTag}>`;
                        });
                        tableHtml += '</tr>';
                    });
                    
                    tableHtml += '</table>';
                });
                
                tableHtml += '</div>';
                tablePreview.innerHTML = tableHtml;
                
                // Show success message
                showMessage(`Successfully extracted ${data.tables.length} table(s)`, 'success');
            } else {
                // No tables found or empty result
                tablePreview.innerHTML = `
                    <div class="alert alert-warning text-center p-3 mb-0" style="background-color: var(--alert-bg); color: var(--warning-color); border: 1px solid var(--warning-color);">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>No tables found in the selected area.</strong>
                        <div class="mt-2 small text-muted">
                            Try adjusting the selection area or modifying the table extraction settings.
                        </div>
                        <div class="mt-3">
                            <button type="button" class="btn btn-sm btn-outline-success" 
                                onclick="extractTable()">
                                <i class="fas fa-sync-alt me-1"></i> Try Again
                            </button>
                        </div>
                    </div>
                `;
            }
        } catch (error) {
            console.error('Error extracting table:', error);
            const tablePreview = document.getElementById('table-preview');
            tablePreview.innerHTML = `
                <div class="alert alert-danger text-center p-3 mb-0" style="background-color: var(--alert-bg); color: var(--danger-color); border: 1px solid var(--danger-color);">
                    <i class="fas fa-exclamation-circle me-2"></i>
                    <strong>Error extracting table</strong>
                    <div class="mt-2 small">
                        ${error.message || 'An unexpected error occurred during table extraction.'}
                    </div>
                    <div class="mt-3">
                        <button type="button" class="btn btn-sm btn-outline-success" 
                            onclick="extractTable()">
                            <i class="fas fa-sync-alt me-1"></i> Try Again
                        </button>
                    </div>
                </div>
            `;
            
            // Show error message
            showMessage('Error extracting table: ' + error.message, 'error');
        }
    }

    function showMessage(message, type = 'info', duration = 3000) {
        const messageContainer = document.getElementById('message-container');
        const messageEl = document.createElement('div');
        messageEl.className = `alert alert-${type} message-animation`;
        messageEl.style.animation = 'fadeIn 0.3s ease-out';
        messageEl.innerHTML = message;
        
        messageContainer.appendChild(messageEl);
        
        setTimeout(() => {
            messageEl.style.animation = 'fadeOut 0.3s ease-out forwards';
            setTimeout(() => {
                messageContainer.removeChild(messageEl);
            }, 300);
        }, duration);
    }

    function showProcessing(show = true) {
        let processingEl = document.querySelector('.table-processing');
        
        if (show) {
            if (!processingEl) {
                processingEl = document.createElement('div');
                processingEl.className = 'table-processing';
                
                const spinner = document.createElement('div');
                spinner.className = 'spinner';
                
                const text = document.createElement('span');
                text.textContent = 'Processing table...';
                
                processingEl.appendChild(spinner);
                processingEl.appendChild(text);
                
                document.querySelector('.pdf-canvas-container').appendChild(processingEl);
            }
        } else if (processingEl) {
            processingEl.addEventListener('animationend', () => {
                processingEl.remove();
            });
            processingEl.style.animation = 'fadeOut 0.3s ease-out forwards';
        }
    }

    function initializePdfViewer() {
        // Add PDF viewer initialization code here
        // Similar to template_create.html's PDF viewer code
        const pdfCanvas = document.getElementById('pdf-canvas');
        const pdfContext = pdfCanvas.getContext('2d');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const pageInput = document.getElementById('page-input');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const zoomResetBtn = document.getElementById('zoom-reset');
        const zoomLevelInput = document.getElementById('zoom-level');
        const rotateCWBtn = document.getElementById('rotate-cw');
        const rotateCCWBtn = document.getElementById('rotate-ccw');
        
        // Add event listeners for navigation
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    renderPage(currentPage - 1);
                }
            });
        }
        
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', () => {
                if (currentPage < pdfDoc.numPages) {
                    renderPage(currentPage + 1);
                }
            });
        }
        
        if (pageInput) {
            pageInput.addEventListener('change', () => {
                const pageNum = parseInt(pageInput.value);
                if (pageNum >= 1 && pageNum <= pdfDoc.numPages) {
                    renderPage(pageNum);
                }
            });
        }
        
        // Add zoom controls
        if (zoomInBtn) {
            zoomInBtn.addEventListener('click', () => {
                if (currentScale < 5.0) {
                    currentScale *= 1.2;
                    renderPage(currentPage);
                    updateZoomLevel();
                }
            });
        }
        
        if (zoomOutBtn) {
            zoomOutBtn.addEventListener('click', () => {
                if (currentScale > 0.1) {
                    currentScale /= 1.2;
                    renderPage(currentPage);
                    updateZoomLevel();
                }
            });
        }
        
        if (zoomResetBtn) {
            zoomResetBtn.addEventListener('click', () => {
                currentScale = 1.0;
                currentRotation = 0;
                renderPage(currentPage);
                updateZoomLevel();
            });
        }
        
        if (zoomLevelInput) {
            zoomLevelInput.addEventListener('change', () => {
                const zoomLevel = parseInt(zoomLevelInput.value);
                if (zoomLevel >= 10 && zoomLevel <= 500) {
                    currentScale = zoomLevel / 100;
                    renderPage(currentPage);
                }
            });
        }
        
        // Add rotation controls
        if (rotateCWBtn) {
            rotateCWBtn.addEventListener('click', () => {
                currentRotation = (currentRotation + 90) % 360;
                renderPage(currentPage);
            });
        }
        
        if (rotateCCWBtn) {
            rotateCCWBtn.addEventListener('click', () => {
                currentRotation = (currentRotation - 90 + 360) % 360;
                renderPage(currentPage);
            });
        }
    }

    async function loadPdf(url) {
        try {
            // Show loading indicator
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'loading-indicator';
            loadingIndicator.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Loading PDF...';
            document.querySelector('.pdf-preview-container').appendChild(loadingIndicator);

            // Load the PDF document
            pdfDoc = await pdfjsLib.getDocument(url).promise;
            
            // Initialize viewer
            initializePdfViewer();
            
            // Update total pages
            document.getElementById('total-pages').textContent = pdfDoc.numPages;
            
            // Show PDF controls
            document.getElementById('pdf-controls').classList.remove('d-none');
            
            // Render first page
            renderPage(1);
            
            // Remove loading indicator
            loadingIndicator.remove();
            
        } catch (error) {
            console.error('Error loading PDF:', error);
            showMessage('Error loading PDF: ' + error.message, 'error');
        }
    }

    async function renderPage(pageNumber) {
        try {
            const page = await pdfDoc.getPage(pageNumber);
            const canvas = document.getElementById('pdf-canvas');
            const context = canvas.getContext('2d');
            
            // Store the current page object globally
            window.currentPageObj = page;
            
            // Get the original viewport (without scaling or rotation)
            const originalViewport = page.getViewport({ scale: 1.0, rotation: 0 });
            originalPdfWidth = originalViewport.width;
            originalPdfHeight = originalViewport.height;
            
            // Get the viewport at the current scale and rotation
            const viewport = page.getViewport({ scale: currentScale, rotation: currentRotation });
            
            // Set canvas dimensions
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            // Update page dimensions display (always show original dimensions)
            document.getElementById('page-width').textContent = Math.round(originalPdfWidth);
            document.getElementById('page-height').textContent = Math.round(originalPdfHeight);
            
            // Clear canvas
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Render the page
            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;
            
            // Update current page
            currentPage = pageNumber;
            window.currentPage = pageNumber; // Store globally
            document.getElementById('page-input').value = pageNumber;
            
            // Update navigation buttons
            document.getElementById('prev-page').disabled = pageNumber <= 1;
            document.getElementById('next-page').disabled = pageNumber >= pdfDoc.numPages;
            
            // Clear any existing selection when changing pages
            document.querySelectorAll('.selection-box').forEach(box => box.remove());
            window.selectedArea = null;
            
            // Redraw guide lines
            redrawGuideLines();
            
        } catch (error) {
            console.error('Error rendering page:', error);
            showMessage('Error rendering page: ' + error.message, 'error');
        }
    }

    // Function to redraw guide lines after zoom/rotation changes
    function redrawGuideLines() {
        // Remove all existing guide lines
        document.querySelectorAll('.guide-line').forEach(line => line.remove());
        
        // Get the canvas and container
        const canvas = document.getElementById('pdf-canvas');
        const container = document.querySelector('.pdf-canvas-wrapper');
        
        if (!canvas || !container || !window.currentPageObj) return;
        
        // Get the current viewport
        const viewport = window.currentPageObj.getViewport({ scale: currentScale, rotation: currentRotation });
        
        // Redraw vertical guide lines
        if (window.verticalGuideLines && window.verticalGuideLines.length > 0) {
            window.verticalGuideLines.forEach(pdfX => {
                // Convert PDF coordinates to screen coordinates
                const screenCoord = convertCoordinates(pdfX, 0, 0, 0, 'toScreen');
                
                // Check if the guide line is within the canvas bounds
                if (screenCoord.x >= 0 && screenCoord.x <= canvas.width) {
                    createGuideLine('vertical', screenCoord.x, true);
                }
            });
        }
        
        // Redraw horizontal guide lines
        if (window.horizontalGuideLines && window.horizontalGuideLines.length > 0) {
            window.horizontalGuideLines.forEach(pdfY => {
                // Convert PDF coordinates to screen coordinates
                const screenCoord = convertCoordinates(0, pdfY, 0, 0, 'toScreen');
                
                // Check if the guide line is within the canvas bounds
                if (screenCoord.y >= 0 && screenCoord.y <= canvas.height) {
                    createGuideLine('horizontal', screenCoord.y, true);
                }
            });
        }
    }

    function updateZoomLevel() {
        const zoomLevel = document.getElementById('zoom-level');
        if (zoomLevel) {
            zoomLevel.value = Math.round(currentScale * 100) + '%';
        }
    }

    function initializeTableExtraction() {
        const extractTableBtn = document.getElementById('extract-table-btn');
        if (extractTableBtn) {
            extractTableBtn.addEventListener('click', function() {
                // Remove the selection check and directly call extractTable
                extractTable();
            });
        }
    }

    function initializeSettingsForm() {
        const saveSettingsBtn = document.getElementById('save-settings-btn');
        if (saveSettingsBtn) {
            saveSettingsBtn.addEventListener('click', function() {
                saveTableSettings();
            });
        }
    }

    // Initialize the application when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize PDF viewer and controls
        if (pdfUrl) {
            console.log('Loading PDF:', pdfUrl);
            console.log('PDF Document ID:', pdfDocumentId);
            loadPdf(pdfUrl);
            initializeSelectionHandlers();
        } else {
            console.error('No PDF URL provided');
            showMessage('Error: No PDF file available', 'error');
        }
        
        // Initialize table extraction functionality
        initializeTableExtraction();
        
        // Initialize settings form
        initializeSettingsForm();
        
        // Initialize line selection modes
        initializeLineSelectionModes();
        
        // Handle window resize to redraw guide lines
        window.addEventListener('resize', function() {
            // Wait a short time to ensure canvas dimensions are updated
            setTimeout(function() {
                redrawGuideLines();
            }, 200);
        });
    });
    
    /**
     * Table Drawing Tool Implementation
     * Allows users to create and manipulate tables on the PDF
     */
    
    // Global variables for table tool
    let isTableMode = false;
    let currentTable = null;
    let tableRows = 3;
    let tableColumns = 3;
    let cellWidth = 50;
    let cellHeight = 20;
    let isCreatingTable = false;
    let isDraggingTable = false;
    let isResizingCell = false;
    let activeTableElement = null;
    let tableCells = [];
    let tableRowHandles = [];
    let tableColumnHandles = [];
    let tableResizeHandle = null;
    let dragStartX = 0;
    let dragStartY = 0;
    let currentlyDraggedElement = null;
    let tableContainer = null;
    let tableToolbar = null;
    let tableGuideLines = [];

    /**
     * Initialize the table tool functionality
     */
    function initializeTableTool() {
        // Table mode button
        const createTableBtn = document.getElementById('createTableBtn');
        const applyTableChangesBtn = document.getElementById('applyTableChangesBtn');
        const clearTableLinesBtn = document.getElementById('clearTableLinesBtn');
        const tableCreationControls = document.getElementById('tableCreationControls');
        
        // Get canvas container
        const canvasWrapper = document.querySelector('.pdf-canvas-container');
        
        if (!createTableBtn || !clearTableLinesBtn || !tableCreationControls || !canvasWrapper) {
            console.error('Table tool elements not found', {
                createTableBtn, 
                clearTableLinesBtn, 
                tableCreationControls, 
                canvasWrapper
            });
            return;
        }
        
        // Set table mode by default
        window.currentSelectionMode = 'table';
        console.log('Table mode activated by default');
        
        createTableBtn.addEventListener('click', function() {
            // Use default values - 2 columns, 1 row
            tableRows = parseInt(document.getElementById('tableRows').value) || 1;
            tableColumns = parseInt(document.getElementById('tableColumns').value) || 2;
            cellWidth = parseInt(document.getElementById('cellWidth').value) || 50;
            cellHeight = parseInt(document.getElementById('cellHeight').value) || 20;
            
            // Set flag to start creating table on next canvas click
            isCreatingTable = true;
            
            // Ensure we're in table mode, not rectangle mode
            window.currentSelectionMode = 'table';
            
            console.log(`Creating table with ${tableRows} rows and ${tableColumns} columns`);
            showMessage(`Creating a ${tableColumns}-column, ${tableRows}-row table. Click on the PDF to place it.`, 'info');
        });
        
        if (applyTableChangesBtn) {
            applyTableChangesBtn.addEventListener('click', function() {
                // Call our improved function instead
                applyTableChanges();
            });
        }
        
        clearTableLinesBtn.addEventListener('click', function() {
            clearTableTool();
            showMessage('Table cleared', 'info');
        });
        
        // Add canvas event listeners for table interaction
        canvasWrapper.addEventListener('mousedown', handleTableMouseDown);
        canvasWrapper.addEventListener('mousemove', handleTableMouseMove);
        document.addEventListener('mouseup', handleTableMouseUp);
        
        console.log('Table tool initialized');
    }

    /**
     * Handle mouse down for table creation and manipulation
     */
    function handleTableMouseDown(event) {
        // Log the current mode for debugging
        console.log(`Table mouse down handler - current mode: ${window.currentSelectionMode}, isCreatingTable: ${isCreatingTable}`);
        
        if (window.currentSelectionMode !== 'table') {
            console.log('Not in table mode, ignoring table mouse down');
            return;
        }
        
        const canvasWrapper = document.querySelector('.pdf-canvas-container');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const rect = canvasWrapper.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // If we're in table creation mode, create a new table
        if (isCreatingTable) {
            createTable(x, y);
            isCreatingTable = false;
            return;
        }
        
        // Check if we're clicking on a table handle or resize handle
        if (event.target.classList.contains('table-handle')) {
            isDraggingTable = true;
            activeTableElement = event.target;
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            currentlyDraggedElement = event.target;
            event.preventDefault();
            return;
        }
        
        if (event.target.classList.contains('table-row-handle')) {
            isDraggingTable = true;
            activeTableElement = event.target;
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            currentlyDraggedElement = event.target;
            event.preventDefault();
            return;
        }
        
        if (event.target.classList.contains('table-col-handle')) {
            isDraggingTable = true;
            activeTableElement = event.target;
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            currentlyDraggedElement = event.target;
            event.preventDefault();
            return;
        }
        
        if (event.target.classList.contains('table-resize-handle')) {
            isResizingCell = true;
            activeTableElement = event.target;
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            currentlyDraggedElement = event.target;
            event.preventDefault();
            return;
        }
    }

    /**
     * Handle mouse move for table manipulation
     */
    function handleTableMouseMove(event) {
        if (currentSelectionMode !== 'table') return;
        if (!isDraggingTable && !isResizingCell) return;
        
        const deltaX = event.clientX - dragStartX;
        const deltaY = event.clientY - dragStartY;
        
        if (isDraggingTable && currentlyDraggedElement) {
            if (currentlyDraggedElement.classList.contains('table-handle')) {
                // Move the entire table
                if (tableContainer) {
                    const left = parseInt(tableContainer.style.left || '0');
                    const top = parseInt(tableContainer.style.top || '0');
                    
                    tableContainer.style.left = (left + deltaX) + 'px';
                    tableContainer.style.top = (top + deltaY) + 'px';
                    
                    // Update stored original position for scroll handling
                    if (tableContainer.dataset.originalLeft) {
                        tableContainer.dataset.originalLeft = parseInt(tableContainer.dataset.originalLeft) + deltaX;
                        tableContainer.dataset.originalTop = parseInt(tableContainer.dataset.originalTop) + deltaY;
                    }
                }
            } else if (currentlyDraggedElement.classList.contains('table-row-handle')) {
                // Resize row height
                const rowIndex = parseInt(currentlyDraggedElement.dataset.rowIndex);
                const cells = document.querySelectorAll(`.table-cell[data-row="${rowIndex}"]`);
                const tableGrid = document.querySelector('.table-grid');
                let totalHeight = 0;
                
                cells.forEach(cell => {
                    const height = parseInt(cell.style.height);
                    const newHeight = Math.max(2, height + deltaY); // Reduced minimum from 20px to 2px
                    cell.style.height = newHeight + 'px';
                    
                    // Only need to check height from one cell in the row
                    if (parseInt(cell.dataset.col) === 0) {
                        totalHeight += newHeight;
                    }
                });
                
                // Update row handle position
                const rowHandle = document.querySelector(`.table-row-handle[data-row-index="${rowIndex}"]`);
                if (rowHandle) {
                    const top = parseInt(rowHandle.style.top);
                    rowHandle.style.top = (top + deltaY) + 'px';
                }
                
                // Calculate cumulative row heights for rows below
                let cumulativeHeight = 0;
                for (let i = 0; i <= rowIndex; i++) {
                    const rowCells = document.querySelectorAll(`.table-cell[data-row="${i}"][data-col="0"]`);
                    if (rowCells.length > 0) {
                        cumulativeHeight += parseInt(rowCells[0].style.height);
                    }
                }
                
                // Update cells in the rows below
                for (let i = rowIndex + 1; i < tableRows; i++) {
                    const rowCells = document.querySelectorAll(`.table-cell[data-row="${i}"]`);
                    rowCells.forEach(cell => {
                        cell.style.top = cumulativeHeight + 'px';
                    });
                    
                    // Update row handle for this row
                    const nextRowHandle = document.querySelector(`.table-row-handle[data-row-index="${i}"]`);
                    if (nextRowHandle) {
                        const rowHeight = parseInt(document.querySelector(`.table-cell[data-row="${i}"][data-col="0"]`).style.height);
                        nextRowHandle.style.top = (cumulativeHeight + rowHeight/2) + 'px';
                    }
                    
                    // Add height of this row for next iteration
                    if (rowCells.length > 0 && parseInt(rowCells[0].dataset.col) === 0) {
                        cumulativeHeight += parseInt(rowCells[0].style.height);
                    }
                }
                
                // Update overall table height
                let newTableHeight = 0;
                for (let i = 0; i < tableRows; i++) {
                    const rowCell = document.querySelector(`.table-cell[data-row="${i}"][data-col="0"]`);
                    if (rowCell) {
                        newTableHeight += parseInt(rowCell.style.height);
                    }
                }
                if (tableGrid) {
                    tableGrid.style.height = newTableHeight + 'px';
                }
                
                // Update resize handle position
                if (tableResizeHandle) {
                    tableResizeHandle.style.bottom = '-7px';
                }
            } else if (currentlyDraggedElement.classList.contains('table-col-handle')) {
                // Resize column width
                const colIndex = parseInt(currentlyDraggedElement.dataset.colIndex);
                const cells = document.querySelectorAll(`.table-cell[data-col="${colIndex}"]`);
                const tableGrid = document.querySelector('.table-grid');
                let totalWidth = 0;
                
                cells.forEach(cell => {
                    const width = parseInt(cell.style.width);
                    const newWidth = Math.max(2, width + deltaX); // Reduced minimum from 20px to 2px
                    cell.style.width = newWidth + 'px';
                    
                    // Only need to check width from one cell in the column
                    if (parseInt(cell.dataset.row) === 0) {
                        totalWidth += newWidth;
                    }
                });
                
                // Update column handle position
                const colHandle = document.querySelector(`.table-col-handle[data-col-index="${colIndex}"]`);
                if (colHandle) {
                    const left = parseInt(colHandle.style.left);
                    colHandle.style.left = (left + deltaX) + 'px';
                }
                
                // Calculate cumulative column widths for columns to the right
                let cumulativeWidth = 0;
                for (let i = 0; i <= colIndex; i++) {
                    const colCells = document.querySelectorAll(`.table-cell[data-col="${i}"][data-row="0"]`);
                    if (colCells.length > 0) {
                        cumulativeWidth += parseInt(colCells[0].style.width);
                    }
                }
                
                // Update cells in the columns to the right
                for (let i = colIndex + 1; i < tableColumns; i++) {
                    const colCells = document.querySelectorAll(`.table-cell[data-col="${i}"]`);
                    colCells.forEach(cell => {
                        cell.style.left = cumulativeWidth + 'px';
                    });
                    
                    // Update column handle for this column
                    const nextColHandle = document.querySelector(`.table-col-handle[data-col-index="${i}"]`);
                    if (nextColHandle) {
                        const colWidth = parseInt(document.querySelector(`.table-cell[data-col="${i}"][data-row="0"]`).style.width);
                        nextColHandle.style.left = (cumulativeWidth + colWidth/2) + 'px';
                    }
                    
                    // Add width of this column for next iteration
                    if (colCells.length > 0 && parseInt(colCells[0].dataset.row) === 0) {
                        cumulativeWidth += parseInt(colCells[0].style.width);
                    }
                }
                
                // Update overall table width
                let newTableWidth = 0;
                for (let i = 0; i < tableColumns; i++) {
                    const colCell = document.querySelector(`.table-cell[data-col="${i}"][data-row="0"]`);
                    if (colCell) {
                        newTableWidth += parseInt(colCell.style.width);
                    }
                }
                if (tableGrid) {
                    tableGrid.style.width = newTableWidth + 'px';
                }
                
                // Update resize handle position
                if (tableResizeHandle) {
                    tableResizeHandle.style.right = '-7px';
                }
            }
            
            dragStartX = event.clientX;
            dragStartY = event.clientY;
        } else if (isResizingCell && currentlyDraggedElement) {
            // Resize the entire table
            const tableGrid = document.querySelector('.table-grid');
            if (tableGrid) {
                const width = parseInt(tableGrid.style.width);
                const height = parseInt(tableGrid.style.height);
                const newWidth = Math.max(30, width + deltaX); // Reduced minimum from 100px to 30px
                const newHeight = Math.max(10, height + deltaY); // Reduced minimum from 40px to 10px
                
                tableGrid.style.width = newWidth + 'px';
                tableGrid.style.height = newHeight + 'px';
                
                // Calculate new cell dimensions
                const newCellWidth = newWidth / tableColumns;
                const newCellHeight = newHeight / tableRows;
                
                // Resize all cells proportionally
                for (let i = 0; i < tableRows; i++) {
                    for (let j = 0; j < tableColumns; j++) {
                        const cell = document.querySelector(`.table-cell[data-row="${i}"][data-col="${j}"]`);
                        if (cell) {
                            cell.style.width = newCellWidth + 'px';
                            cell.style.height = newCellHeight + 'px';
                            cell.style.left = (j * newCellWidth) + 'px';
                            cell.style.top = (i * newCellHeight) + 'px';
                        }
                    }
                }
                
                // Update row handles
                for (let i = 0; i < tableRows; i++) {
                    const rowHandle = document.querySelector(`.table-row-handle[data-row-index="${i}"]`);
                    if (rowHandle) {
                        rowHandle.style.top = (i * newCellHeight + newCellHeight/2) + 'px';
                    }
                }
                
                // Update column handles
                for (let j = 0; j < tableColumns; j++) {
                    const colHandle = document.querySelector(`.table-col-handle[data-col-index="${j}"]`);
                    if (colHandle) {
                        colHandle.style.left = (j * newCellWidth + newCellWidth/2) + 'px';
                    }
                }
                
                // Update resize handle position
                if (tableResizeHandle) {
                    tableResizeHandle.style.right = '-7px';
                    tableResizeHandle.style.bottom = '-7px';
                }
            }
            
            dragStartX = event.clientX;
            dragStartY = event.clientY;
        }
    }

    /**
     * Handle mouse up for table manipulation
     */
    function handleTableMouseUp(event) {
        if (isDraggingTable || isResizingCell) {
            isDraggingTable = false;
            isResizingCell = false;
            currentlyDraggedElement = null;
            
            // If we were manipulating the table, update the rectangle lines
            if (currentSelectionMode === 'table' && activeTableElement) {
                updateTableToRectangleLines(false);
                activeTableElement = null;
            }
        }
    }

    /**
     * Create a new table at the specified position
     */
    function createTable(x, y) {
        // Clear any existing table
        clearTableTool();
        
        const canvasWrapper = document.querySelector('.pdf-canvas-container');
        const pdfContent = document.querySelector('.pdf-content');
        
        // Create table container
        tableContainer = document.createElement('div');
        tableContainer.className = 'table-container';
        
        // Position relative to the canvas, accounting for scroll position
        tableContainer.style.left = (x + canvasWrapper.offsetLeft - pdfContent.scrollLeft) + 'px';
        tableContainer.style.top = (y + canvasWrapper.offsetTop - pdfContent.scrollTop) + 'px';
        
        // Create table toolbar - now higher above the table
        tableToolbar = document.createElement('div');
        tableToolbar.className = 'table-toolbar';
        tableToolbar.style.top = '-70px'; // Ensure it's positioned higher
        
        // Add toolbar buttons with icons and clearer labels
        const addRowBtn = document.createElement('button');
        addRowBtn.innerHTML = '<i class="fas fa-plus me-1"></i> Row';
        addRowBtn.title = 'Add a new row';
        addRowBtn.addEventListener('click', () => addTableRow());
        
        const addColBtn = document.createElement('button');
        addColBtn.innerHTML = '<i class="fas fa-plus me-1"></i> Column';
        addColBtn.title = 'Add a new column';
        addColBtn.addEventListener('click', () => addTableColumn());
        
        const removeRowBtn = document.createElement('button');
        removeRowBtn.innerHTML = '<i class="fas fa-minus me-1"></i> Row';
        removeRowBtn.title = 'Remove last row';
        removeRowBtn.addEventListener('click', () => removeTableRow());
        
        const removeColBtn = document.createElement('button');
        removeColBtn.innerHTML = '<i class="fas fa-minus me-1"></i> Column';
        removeColBtn.title = 'Remove last column';
        removeColBtn.addEventListener('click', () => removeTableColumn());
        
        tableToolbar.appendChild(addRowBtn);
        tableToolbar.appendChild(addColBtn);
        tableToolbar.appendChild(removeRowBtn);
        tableToolbar.appendChild(removeColBtn);
        
        tableContainer.appendChild(tableToolbar);
        
        // Create the table grid
        const tableGrid = document.createElement('div');
        tableGrid.className = 'table-grid';
        tableGrid.style.width = (tableColumns * cellWidth) + 'px';
        tableGrid.style.height = (tableRows * cellHeight) + 'px';
        
        // Add table drag handle
        const tableHandle = document.createElement('div');
        tableHandle.className = 'table-handle';
        tableHandle.style.top = '-20px'; // Position it higher
        tableHandle.style.left = '-20px'; // Position it further left
        tableHandle.title = 'Drag to move table';
        tableGrid.appendChild(tableHandle);
        
        // Add table resize handle
        tableResizeHandle = document.createElement('div');
        tableResizeHandle.className = 'table-resize-handle';
        tableGrid.appendChild(tableResizeHandle);
        
        // Create row handles
        for (let i = 0; i < tableRows; i++) {
            const rowHandle = document.createElement('div');
            rowHandle.className = 'table-row-handle';
            rowHandle.dataset.rowIndex = i;
            rowHandle.style.left = '-15px';
            rowHandle.style.top = (i * cellHeight + cellHeight / 2) + 'px';
            tableGrid.appendChild(rowHandle);
            tableRowHandles.push(rowHandle);
        }
        
        // Create column handles
        for (let j = 0; j < tableColumns; j++) {
            const colHandle = document.createElement('div');
            colHandle.className = 'table-col-handle';
            colHandle.dataset.colIndex = j;
            colHandle.style.top = '-15px';
            colHandle.style.left = (j * cellWidth + cellWidth / 2) + 'px';
            tableGrid.appendChild(colHandle);
            tableColumnHandles.push(colHandle);
        }
        
        // Create cells
        for (let i = 0; i < tableRows; i++) {
            for (let j = 0; j < tableColumns; j++) {
                const cell = document.createElement('div');
                cell.className = 'table-cell';
                cell.dataset.row = i;
                cell.dataset.col = j;
                cell.style.top = (i * cellHeight) + 'px';
                cell.style.left = (j * cellWidth) + 'px';
                cell.style.width = cellWidth + 'px';
                cell.style.height = cellHeight + 'px';
                
                tableGrid.appendChild(cell);
                tableCells.push(cell);
            }
        }
        
        tableContainer.appendChild(tableGrid);
        canvasWrapper.appendChild(tableContainer);
        
        currentTable = tableGrid;
        
        // Add scroll event listener to keep table aligned with PDF when scrolling
        const pdfContentElement = document.querySelector('.pdf-content');
        if (pdfContentElement) {
            pdfContentElement.addEventListener('scroll', handlePdfScroll);
        }
        
        // Update the rectangle lines data but don't update the textarea yet
        updateTableToRectangleLines(false);
        
        // Show the apply changes button
        const applyChangesBtn = document.getElementById('applyTableChangesBtn');
        if (applyChangesBtn) {
            applyChangesBtn.style.display = 'inline-block';
        }
        
        console.log('Table created. Click "Apply Changes" to add points to the points details.');
        showMessage('Table created. Click "Apply Changes" to add points to the points details.', 'info');
    }

    /**
     * Handle PDF scroll to keep table aligned with PDF content
     */
    function handlePdfScroll(event) {
        if (!tableContainer) return;
        
        const pdfContent = document.querySelector('.pdf-content');
        const canvasWrapper = document.querySelector('.pdf-canvas-container');
        
        // Get the original position (without scroll offset)
        const originalLeft = parseInt(tableContainer.dataset.originalLeft || tableContainer.style.left);
        const originalTop = parseInt(tableContainer.dataset.originalTop || tableContainer.style.top);
        
        // Store original position if not already stored
        if (!tableContainer.dataset.originalLeft) {
            tableContainer.dataset.originalLeft = tableContainer.style.left;
            tableContainer.dataset.originalTop = tableContainer.style.top;
        }
        
        // Calculate new position based on scroll
        const newLeft = originalLeft - pdfContent.scrollLeft;
        const newTop = originalTop - pdfContent.scrollTop;
        
        // Update position
        tableContainer.style.left = newLeft + 'px';
        tableContainer.style.top = newTop + 'px';
    }

    /**
     * Convert the table cells to rectangle lines and update the internal data
     * but don't update the textarea until the Apply Changes button is clicked
     */
    function updateTableToRectangleLines(updateTextarea = false) {
        if (!currentTable) return;
        
        const rectangleLines = [];
        const tableRect = tableContainer.getBoundingClientRect();
        const pdfCanvas = document.getElementById('pdf-canvas');
        const canvasRect = pdfCanvas.getBoundingClientRect();
        
        // Convert screen coordinates to canvas coordinates
        const tableOffsetX = tableRect.left - canvasRect.left;
        const tableOffsetY = tableRect.top - canvasRect.top;
        
        // Collect all unique x and y coordinates to create grid lines
        const xCoordinates = new Set();
        const yCoordinates = new Set();
        
        // Store PDF coordinates for each cell
        const cellPdfCoordinates = [];
        
        // Process each cell to gather coordinates
        document.querySelectorAll('.table-cell').forEach(cell => {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            const cellLeft = parseFloat(cell.style.left);
            const cellTop = parseFloat(cell.style.top);
            const cellWidth = parseFloat(cell.style.width);
            const cellHeight = parseFloat(cell.style.height);
            
            // Calculate absolute position of cell in canvas coordinates
            const absLeft = tableOffsetX + cellLeft;
            const absTop = tableOffsetY + cellTop;
            const absRight = absLeft + cellWidth;
            const absBottom = absTop + cellHeight;
            
            // Convert to PDF coordinates
            const topLeft = convertCoordinates(absLeft, absTop, 0, 0, 'toPdf');
            const bottomRight = convertCoordinates(absRight, absBottom, 0, 0, 'toPdf');
            
            // Store cell coordinates
            cellPdfCoordinates.push({
                row,
                col,
                x1: topLeft.x,
                y1: topLeft.y,
                x2: bottomRight.x,
                y2: bottomRight.y
            });
            
            // Add coordinates to sets
            xCoordinates.add(topLeft.x);
            xCoordinates.add(bottomRight.x);
            yCoordinates.add(topLeft.y);
            yCoordinates.add(bottomRight.y);
        });
        
        // Convert sets to sorted arrays
        const xCoordsSorted = Array.from(xCoordinates).sort((a, b) => a - b);
        const yCoordsSorted = Array.from(yCoordinates).sort((a, b) => a - b);
        
        console.log(`Creating table with ${xCoordsSorted.length} vertical lines and ${yCoordsSorted.length} horizontal lines`);
        
        // Create horizontal lines (spanning the entire table width)
        yCoordsSorted.forEach(y => {
            rectangleLines.push([[xCoordsSorted[0], y], [xCoordsSorted[xCoordsSorted.length - 1], y]]);
        });
        
        // Create vertical lines (spanning the entire table height)
        xCoordsSorted.forEach(x => {
            rectangleLines.push([[x, yCoordsSorted[0]], [x, yCoordsSorted[yCoordsSorted.length - 1]]]);
        });
        
        // Initialize rectangleGuideLines if needed
        if (!window.rectangleGuideLines) {
            window.rectangleGuideLines = [];
        }
        
        // Save the table lines
        tableGuideLines = rectangleLines;
        
        // Update the combined lines - remove old table lines and add new ones
        window.rectangleGuideLines = [
            ...window.rectangleGuideLines.filter(line => !tableGuideLines.includes(line)),
            ...rectangleLines
        ];
        
        // Log the number of lines created
        console.log(`Generated ${rectangleLines.length} lines for the table (${xCoordsSorted.length} vertical, ${yCoordsSorted.length} horizontal)`);
        
        // Only update the textarea if requested (when Apply Changes is clicked)
        if (updateTextarea) {
            updateAddLinesTextarea();
            console.log(`Updated add_lines textarea with ${rectangleLines.length} lines from table`);
        } else {
            console.log(`Prepared ${rectangleLines.length} lines from table (not yet in textarea)`);
        }
    }

    /**
     * Add a new row to the table
     */
    function addTableRow() {
        if (!currentTable) return;
        
        // Calculate position for new row
        const newRowIndex = tableRows;
        
        // Determine the height for the new row based on the last row's height
        let newRowHeight = cellHeight; // Default height
        if (tableRows > 0) {
            // Get the height of the last row by checking a cell in that row
            const lastRowCell = document.querySelector(`.table-cell[data-row="${tableRows-1}"][data-col="0"]`);
            if (lastRowCell) {
                newRowHeight = parseFloat(lastRowCell.style.height);
            }
        }
        
        const lastRowY = (tableRows > 0) ? 
            parseFloat(document.querySelector(`.table-cell[data-row="${tableRows-1}"][data-col="0"]`)?.style.top || '0') + 
            parseFloat(document.querySelector(`.table-cell[data-row="${tableRows-1}"][data-col="0"]`)?.style.height || '0') :
            0;
        
        // Update table dimensions
        tableRows++;
        
        // Calculate total table height by summing all row heights
        let totalTableHeight = lastRowY + newRowHeight;
        currentTable.style.height = totalTableHeight + 'px';
        
        // Add row handle
        const rowHandle = document.createElement('div');
        rowHandle.className = 'table-row-handle';
        rowHandle.dataset.rowIndex = newRowIndex;
        rowHandle.style.left = '-15px';
        rowHandle.style.top = (lastRowY + newRowHeight / 2) + 'px';
        currentTable.appendChild(rowHandle);
        tableRowHandles.push(rowHandle);
        
        // Add cells for the new row
        for (let j = 0; j < tableColumns; j++) {
            // Get width from existing column
            let colWidth = cellWidth;
            const columnRefCell = document.querySelector(`.table-cell[data-row="0"][data-col="${j}"]`);
            if (columnRefCell) {
                colWidth = parseFloat(columnRefCell.style.width);
            }
            
            // Get column position
            let colLeft = j * colWidth;
            if (j > 0) {
                const prevCell = document.querySelector(`.table-cell[data-row="0"][data-col="${j-1}"]`);
                if (prevCell) {
                    colLeft = parseFloat(prevCell.style.left) + parseFloat(prevCell.style.width);
                }
            }
            
            const cell = document.createElement('div');
            cell.className = 'table-cell';
            cell.dataset.row = newRowIndex;
            cell.dataset.col = j;
            cell.style.top = lastRowY + 'px';
            cell.style.left = colLeft + 'px';
            cell.style.width = colWidth + 'px';
            cell.style.height = newRowHeight + 'px';
            
            currentTable.appendChild(cell);
            tableCells.push(cell);
        }
        
        // Update resize handle position
        if (tableResizeHandle) {
            tableResizeHandle.style.bottom = '-7px';
        }
        
        // Update rectangle lines
        updateTableToRectangleLines(false);
        
        console.log(`Added new row. Table now has ${tableRows} rows`);
        showMessage('Added new row to table', 'success');
    }

    /**
     * Add a new column to the table
     */
    function addTableColumn() {
        if (!currentTable) return;
        
        // Calculate position for new column
        const newColIndex = tableColumns;
        
        // Determine the width for the new column based on the last column's width
        let newColWidth = cellWidth; // Default width
        if (tableColumns > 0) {
            // Get the width of the last column by checking a cell in that column
            const lastColCell = document.querySelector(`.table-cell[data-row="0"][data-col="${tableColumns-1}"]`);
            if (lastColCell) {
                newColWidth = parseFloat(lastColCell.style.width);
            }
        }
        
        const lastColX = (tableColumns > 0) ? 
            parseFloat(document.querySelector(`.table-cell[data-row="0"][data-col="${tableColumns-1}"]`)?.style.left || '0') + 
            parseFloat(document.querySelector(`.table-cell[data-row="0"][data-col="${tableColumns-1}"]`)?.style.width || '0') :
            0;
        
        // Update table dimensions
        tableColumns++;
        
        // Calculate total table width by summing all column widths
        let totalTableWidth = lastColX + newColWidth;
        currentTable.style.width = totalTableWidth + 'px';
        
        // Add column handle
        const colHandle = document.createElement('div');
        colHandle.className = 'table-col-handle';
        colHandle.dataset.colIndex = newColIndex;
        colHandle.style.top = '-15px';
        colHandle.style.left = (lastColX + newColWidth / 2) + 'px';
        currentTable.appendChild(colHandle);
        tableColumnHandles.push(colHandle);
        
        // Add cells for the new column
        for (let i = 0; i < tableRows; i++) {
            // Get height from existing row
            let rowHeight = cellHeight;
            const rowRefCell = document.querySelector(`.table-cell[data-row="${i}"][data-col="0"]`);
            if (rowRefCell) {
                rowHeight = parseFloat(rowRefCell.style.height);
            }
            
            // Get row position
            let rowTop = i * rowHeight;
            if (i > 0) {
                const prevCell = document.querySelector(`.table-cell[data-row="${i-1}"][data-col="0"]`);
                if (prevCell) {
                    rowTop = parseFloat(prevCell.style.top) + parseFloat(prevCell.style.height);
                }
            }
            
            const cell = document.createElement('div');
            cell.className = 'table-cell';
            cell.dataset.row = i;
            cell.dataset.col = newColIndex;
            cell.style.top = rowTop + 'px';
            cell.style.left = lastColX + 'px';
            cell.style.width = newColWidth + 'px';
            cell.style.height = rowHeight + 'px';
            
            currentTable.appendChild(cell);
            tableCells.push(cell);
        }
        
        // Update resize handle position
        if (tableResizeHandle) {
            tableResizeHandle.style.right = '-7px';
        }
        
        // Update rectangle lines
        updateTableToRectangleLines(false);
        
        console.log(`Added new column. Table now has ${tableColumns} columns`);
        showMessage('Added new column to table', 'success');
    }

    /**
     * Remove the last row from the table
     */
    function removeTableRow() {
        if (!currentTable || tableRows <= 1) return;
        
        // Remove cells from the last row
        const lastRowIndex = tableRows - 1;
        const cellsToRemove = document.querySelectorAll(`.table-cell[data-row="${lastRowIndex}"]`);
        cellsToRemove.forEach(cell => {
            cell.remove();
        });
        
        // Remove row handle
        const rowHandleToRemove = document.querySelector(`.table-row-handle[data-row-index="${lastRowIndex}"]`);
        if (rowHandleToRemove) {
            rowHandleToRemove.remove();
        }
        
        // Update table dimensions
        tableRows--;
        currentTable.style.height = (tableRows * cellHeight) + 'px';
        
        // Update resize handle position
        if (tableResizeHandle) {
            tableResizeHandle.style.bottom = '-7px';
        }
        
        // Update rectangle lines
        updateTableToRectangleLines(false);
        
        console.log(`Removed row. Table now has ${tableRows} rows`);
        showMessage('Removed row from table', 'info');
    }

    /**
     * Remove the last column from the table
     */
    function removeTableColumn() {
        if (!currentTable || tableColumns <= 1) return;
        
        // Remove cells from the last column
        const lastColIndex = tableColumns - 1;
        const cellsToRemove = document.querySelectorAll(`.table-cell[data-col="${lastColIndex}"]`);
        cellsToRemove.forEach(cell => {
            cell.remove();
        });
        
        // Remove column handle
        const colHandleToRemove = document.querySelector(`.table-col-handle[data-col-index="${lastColIndex}"]`);
        if (colHandleToRemove) {
            colHandleToRemove.remove();
        }
        
        // Update table dimensions
        tableColumns--;
        currentTable.style.width = (tableColumns * cellWidth) + 'px';
        
        // Update resize handle position
        if (tableResizeHandle) {
            tableResizeHandle.style.right = '-7px';
        }
        
        // Update rectangle lines
        updateTableToRectangleLines(false);
        
        console.log(`Removed column. Table now has ${tableColumns} columns`);
        showMessage('Removed column from table', 'info');
    }

    /**
     * Clear the current table
     */
    function clearTableTool() {
        // Log table lines info before clearing
        if (tableGuideLines) {
            console.log(`Clearing table with ${tableGuideLines.length} guide lines`);
        }
        
        // Remove table container if it exists
        const existingTable = document.querySelector('.table-container');
        if (existingTable) {
            existingTable.remove();
        }
        
        // Remove scroll event listener
        const pdfContentElement = document.querySelector('.pdf-content');
        if (pdfContentElement) {
            pdfContentElement.removeEventListener('scroll', handlePdfScroll);
        }
        
        // Reset global variables
        currentTable = null;
        tableCells = [];
        tableRowHandles = [];
        tableColumnHandles = [];
        tableResizeHandle = null;
        tableContainer = null;
        tableToolbar = null;
        
        // If we have table guide lines, remove them from rectangle lines
        if (tableGuideLines && tableGuideLines.length > 0) {
            if (window.rectangleGuideLines) {
                const beforeCount = window.rectangleGuideLines.length;
                
                // Create a new array with everything except the table guide lines
                window.rectangleGuideLines = window.rectangleGuideLines.filter(line => 
                    !tableGuideLines.some(tableLine => 
                        JSON.stringify(line) === JSON.stringify(tableLine)
                    )
                );
                
                const afterCount = window.rectangleGuideLines.length;
                console.log(`Removed ${beforeCount - afterCount} lines from rectangle guide lines`);
                
                // Update the textarea
                updateAddLinesTextarea();
            }
            
            tableGuideLines = [];
        }
        
        // Hide the apply changes button
        const applyChangesBtn = document.getElementById('applyTableChangesBtn');
        if (applyChangesBtn) {
            applyChangesBtn.style.display = 'none';
        }
        
        console.log('Table cleared');
        
        // Reset the creating table flag to prevent issues with rectangle mode
        isCreatingTable = false;
    }

    // Initialize the table tool
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize the table tool immediately
        initializeTableTool();
        
        // Make sure table mode is the default
        window.currentSelectionMode = 'table';
    });

    /**
     * Visualize table grid lines for debugging
     */
    function visualizeTableGridLines() {
        if (!currentTable || !tableGuideLines || tableGuideLines.length === 0) {
            console.log('No table or table guide lines to visualize');
            return;
        }
        
        // Group lines by direction (horizontal vs vertical)
        const horizontalLines = [];
        const verticalLines = [];
        
        tableGuideLines.forEach(line => {
            const [[x1, y1], [x2, y2]] = line;
            if (y1 === y2) {
                // Horizontal line
                horizontalLines.push({ y: y1, x1, x2 });
            } else if (x1 === x2) {
                // Vertical line
                verticalLines.push({ x: x1, y1, y2 });
            }
        });
        
        console.log(`Table has ${horizontalLines.length} horizontal lines and ${verticalLines.length} vertical lines`);
        console.log(`Total lines: ${tableGuideLines.length}`);
        
        // Count cells based on grid intersections
        const cells = (horizontalLines.length - 1) * (verticalLines.length - 1);
        console.log(`This creates a table with approximately ${cells} cells`);
        
        return {
            horizontal: horizontalLines.length,
            vertical: verticalLines.length,
            total: tableGuideLines.length,
            cells
        };
    }
    
    if (applyTableChangesBtn) {
        applyTableChangesBtn.addEventListener('click', function() {
            // Call our improved function instead
            applyTableChanges();
        });
    }
    
    // Define our enhanced applyTableChanges function
    function applyTableChanges() {
        if (currentTable) {
            // Show processing animation
            showProcessing(true);
            
            // Apply changes to the table structure
            setTimeout(() => {
                updateTableToRectangleLines(true);
                
                // Visualize the lines for debugging
                const stats = visualizeTableGridLines();
                
                // Hide processing animation after a short delay
                setTimeout(() => {
                    showProcessing(false);
                    
                    // Show success message
                    if (stats) {
                        showMessage(`Table with ${stats.cells} cells created using ${stats.total} lines`, 'success');
                    } else {
                        showMessage('Table points added to points details', 'success');
                    }
                }, 500);
            }, 300); // Short delay to show processing
        }
    }
</script>
{% endblock %}

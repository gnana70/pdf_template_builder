{% extends 'base/base.html' %}
{% load static %}

{% block title %}Configure Template: {{ template.name }}{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf_viewer.min.css">
<style>
    .template-container {
        display: flex;
        height: calc(100vh - 200px);
        min-height: 600px;
    }
    
    .pdf-viewer {
        width: 60%;
        overflow: auto;
        border: 1px solid #e5e7eb;
        position: relative;
    }
    
    .fields-section {
        width: 40%;
        overflow: auto;
        border: 1px solid #e5e7eb;
        border-left: none;
    }
    
    #pdf-container {
        position: relative;
        min-height: 200px;
    }
    
    .selection-overlay {
        position: absolute;
        border: 2px dashed #4f46e5;
        background-color: rgba(79, 70, 229, 0.1);
        pointer-events: none;
    }
    
    .field-overlay {
        position: absolute;
        border: 2px solid #10B981;
        background-color: rgba(16, 185, 129, 0.1);
        cursor: pointer;
    }
    
    .field-overlay.active {
        border-color: #F59E0B;
        background-color: rgba(245, 158, 11, 0.15);
    }
    
    .field-overlay .field-label {
        position: absolute;
        top: -20px;
        left: 0;
        background-color: #10B981;
        color: white;
        padding: 0 4px;
        font-size: 10px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
    }
    
    .page-controls {
        position: sticky;
        top: 0;
        background-color: white;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    /* Loading animation */
    .pdf-loading {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
    }
    
    .hidden {
        display: none !important;
    }
    
    .pdf-loading-spinner {
        border: 3px solid rgba(79, 70, 229, 0.3);
        border-radius: 50%;
        border-top: 3px solid #4f46e5;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>
{% endblock %}

{% block content %}
<div class="bg-white shadow overflow-hidden sm:rounded-lg mb-4">
    <div class="px-4 py-4 sm:px-6 flex justify-between items-center">
        <div>
            <h1 class="text-2xl font-bold text-gray-900">
                Configure Template: {{ template.name }}
            </h1>
            <p class="mt-1 max-w-2xl text-sm text-gray-500">
                Add and configure fields for data extraction
            </p>
        </div>
        <div class="flex space-x-2">
            <a href="{% url 'template_list' %}" class="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                <i class="fas fa-arrow-left mr-2"></i> Back to Templates
            </a>
        </div>
    </div>
</div>

<div class="template-container">
    <!-- PDF Viewer (60%) -->
    <div class="pdf-viewer">
        <div class="page-controls bg-gray-100 p-2 border-b flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <button id="prev-page" class="p-2 rounded-md bg-white border border-gray-300 hover:bg-gray-50 disabled:opacity-50">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <span>Page</span>
                <div class="inline-flex items-center">
                    <input type="number" min="1" id="page-input" class="w-12 border-gray-300 rounded-md text-center" value="1">
                    <span class="mx-1">of <span id="page-count">1</span></span>
                </div>
                <button id="next-page" class="p-2 rounded-md bg-white border border-gray-300 hover:bg-gray-50 disabled:opacity-50">
                    <i class="fas fa-chevron-right"></i>
                </button>
                
                <div class="ml-4 border-l border-gray-300 pl-4">
                    <div class="flex items-center bg-white border border-gray-300 rounded-md overflow-hidden">
                        <button id="zoom-out" class="p-2 hover:bg-gray-100 focus:outline-none">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <span id="zoom-level" class="px-2 border-l border-r border-gray-300 min-w-[60px] text-center">100%</span>
                        <button id="zoom-in" class="p-2 hover:bg-gray-100 focus:outline-none">
                            <i class="fas fa-search-plus"></i>
                        </button>
                        <span id="page-resolution" class="ml-3 text-xs text-gray-500"></span>
                    </div>
                </div>
            </div>
            <div>
                <span id="loading-status" class="text-sm text-gray-500">Loading PDF...</span>
            </div>
        </div>
        
        <div id="pdf-container" class="relative">
            <div id="pdf-loading" class="pdf-loading absolute top-0 left-0 w-full h-full bg-white bg-opacity-90 z-10">
            <div class="flex flex-col items-center">
                <div class="pdf-loading-spinner"></div>
                <p class="mt-4 text-gray-600">Loading PDF...</p>
            </div>
            </div>
        </div>
    </div>
    
    <!-- Fields Section (40%) -->
    <div class="fields-section">
        <div class="bg-gray-100 p-3 border-b">
            <div class="flex justify-between items-center">
                <h2 class="text-lg font-medium text-gray-900">Template Fields</h2>
                <button id="add-field-btn" class="inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    <i class="fas fa-plus mr-1"></i> Add Field
                </button>
            </div>
            <p class="mt-1 text-sm text-gray-500">Configure fields for data extraction</p>
        </div>
        
        <!-- Inline Field Form - Initially Hidden -->
        <div id="inline-field-form" class="p-4 border-b border-gray-200 bg-gray-50 hidden">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-md font-medium text-gray-900" id="inline-form-title">Add Field</h3>
                <button id="close-inline-form-btn" class="text-gray-400 hover:text-gray-500">
                    <i class="fas fa-times"></i>
                                </button>
</div>

            <form id="field-form" class="mt-2">
                    {% csrf_token %}
                    <input type="hidden" id="field-id" name="field_id" value="">
                    
                <div class="mb-3">
                        <label for="field-name" class="block text-sm font-medium text-gray-700">Field Name</label>
                    <select id="field-name" name="name" class="form-select rounded-md shadow-sm border-gray-300 w-full mt-1">
                        <option value="">-- Select a field --</option>
                    </select>
                    </div>
                    
                <div class="mb-3">
                        <div class="flex items-center">
                            <input type="checkbox" id="custom-name-enabled" name="custom_name_enabled" class="form-checkbox">
                            <label for="custom-name-enabled" class="ml-2 block text-sm font-medium text-gray-700">Use Custom Name</label>
                        </div>
                        <div id="custom-name-container" class="mt-2 hidden">
                            <input type="text" id="custom-name" name="custom_name" class="form-input rounded-md shadow-sm border-gray-300 w-full">
                        </div>
                    </div>
                    
                <div class="mb-3">
                        <label for="field-page" class="block text-sm font-medium text-gray-700">Page *</label>
                        <input type="number" id="field-page" name="page" min="1" value="1" required class="form-input rounded-md shadow-sm border-gray-300 w-full mt-1">
                    </div>
                    
                <div class="grid grid-cols-2 gap-4 mb-3">
                        <div>
                            <label for="field-x" class="block text-sm font-medium text-gray-700">X *</label>
                            <input type="number" id="field-x" name="x" step="0.01" required class="form-input rounded-md shadow-sm border-gray-300 w-full mt-1">
                        </div>
                        <div>
                            <label for="field-y" class="block text-sm font-medium text-gray-700">Y *</label>
                            <input type="number" id="field-y" name="y" step="0.01" required class="form-input rounded-md shadow-sm border-gray-300 w-full mt-1">
                        </div>
                    </div>
                    
                <div class="grid grid-cols-2 gap-4 mb-3">
                        <div>
                            <label for="field-x1" class="block text-sm font-medium text-gray-700">Width (X1) *</label>
                            <input type="number" id="field-x1" name="x1" step="0.01" required class="form-input rounded-md shadow-sm border-gray-300 w-full mt-1">
                        </div>
                        <div>
                            <label for="field-y1" class="block text-sm font-medium text-gray-700">Height (Y1) *</label>
                            <input type="number" id="field-y1" name="y1" step="0.01" required class="form-input rounded-md shadow-sm border-gray-300 w-full mt-1">
                        </div>
                    </div>
                    
                <div class="mb-3">
                        <button type="button" id="select-area-btn" class="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                            <i class="fas fa-crop-alt mr-2"></i> Select Area on PDF
                        </button>
                    </div>
                    
                <div class="mb-3">
                    <label for="python-function" class="block text-sm font-medium text-gray-700">Python Function</label>
                    <div class="mt-1">
                        <select id="python-function" name="python_function" class="form-select rounded-md shadow-sm border-gray-300 w-full">
                            <option value="">-- None --</option>
                        </select>
                    </div>
                    <p class="mt-1 text-xs text-gray-500">Optional: Associate a Python function with this field for custom processing</p>
                </div>
                
                <div id="extracted-text-container" class="mb-3 hidden">
                        <label class="block text-sm font-medium text-gray-700">Extracted Text</label>
                        <div id="extracted-text" class="mt-1 p-2 bg-gray-100 text-gray-900 rounded-md min-h-[50px] text-sm"></div>
                        <input type="hidden" id="extracted-text-input" name="extracted_text">
                    </div>
                
                <div class="flex justify-end space-x-2">
                    <button type="button" id="cancel-field-btn" class="inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                        Cancel
                    </button>
                    <button type="button" id="save-field-btn" class="inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-indigo-600 text-sm font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                        Save Field
                    </button>
                </div>
                </form>
            </div>
        
        <div id="fields-list" class="divide-y divide-gray-200">
            {% if fields %}
                {% for field in fields %}
                    <div class="field-item p-4 hover:bg-gray-50" data-field-id="{{ field.id }}">
                        <div class="flex justify-between">
                            <h3 class="text-md font-medium text-gray-900">{{ field.name }}</h3>
                            <div class="flex space-x-2">
                                <button class="edit-field-btn text-blue-600 hover:text-blue-800" data-field-id="{{ field.id }}">
                                    <i class="fas fa-edit"></i>
                </button>
                                <button class="delete-field-btn text-red-600 hover:text-red-800" data-field-id="{{ field.id }}">
                                    <i class="fas fa-trash"></i>
                </button>
            </div>
        </div>
                        {% if field.custom_name %}
                        <p class="text-sm text-gray-500">Custom Name: {{ field.custom_name }}</p>
                        {% endif %}
                        <div class="mt-2 text-sm text-gray-600">
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <span class="text-gray-500">Page:</span> {{ field.page }}
                                </div>
                                <div>
                                    <span class="text-gray-500">Position:</span> ({{ field.x|floatformat:2 }}, {{ field.y|floatformat:2 }})
                                </div>
                                <div class="col-span-2">
                                    <span class="text-gray-500">Size:</span> {{ field.x1|floatformat:2 }} x {{ field.y1|floatformat:2 }}
                                </div>
                                {% if field.extracted_text %}
                                <div class="col-span-2 mt-1">
                                    <span class="text-gray-500">Extracted Text:</span> 
                                    <span class="bg-gray-100 px-1 py-0.5 rounded text-gray-800">{{ field.extracted_text }}</span>
                                </div>
                                {% endif %}
                                {% if field.python_function %}
                                <div class="col-span-2 mt-1">
                                    <span class="text-gray-500">Python Function:</span> 
                                    <span class="bg-indigo-100 text-indigo-800 px-1 py-0.5 rounded">{{ field.python_function.name }}</span>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                {% endfor %}
            {% else %}
                <div class="p-8 text-center">
                    <div class="text-gray-400 mb-4">
                        <i class="fas fa-file-alt text-4xl"></i>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mb-1">No fields defined</h3>
                    <p class="text-gray-500 mb-4">Start by adding fields to your template</p>
                </div>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js"></script>
<script>
    // Set the PDF.js worker path
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
    
    document.addEventListener('DOMContentLoaded', function() {
        // PDF viewer
        const pdfContainer = document.getElementById('pdf-container');
        const pageInput = document.getElementById('page-input');
        const pageCount = document.getElementById('page-count');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const zoomLevelEl = document.getElementById('zoom-level');
        const pageResolutionEl = document.getElementById('page-resolution');
        const loadingStatus = document.getElementById('loading-status');
        const pdfLoading = document.getElementById('pdf-loading');
        
        // Field form elements
        const inlineFieldForm = document.getElementById('inline-field-form');
        const inlineFormTitle = document.getElementById('inline-form-title');
        const closeInlineFormBtn = document.getElementById('close-inline-form-btn');
        const fieldForm = document.getElementById('field-form');
        const fieldIdInput = document.getElementById('field-id');
        const fieldNameInput = document.getElementById('field-name');
        const customNameEnabled = document.getElementById('custom-name-enabled');
        const customNameContainer = document.getElementById('custom-name-container');
        const customNameInput = document.getElementById('custom-name');
        const fieldPageInput = document.getElementById('field-page');
        const fieldXInput = document.getElementById('field-x');
        const fieldYInput = document.getElementById('field-y');
        const fieldX1Input = document.getElementById('field-x1');
        const fieldY1Input = document.getElementById('field-y1');
        const selectAreaBtn = document.getElementById('select-area-btn');
        const saveFieldBtn = document.getElementById('save-field-btn');
        const cancelFieldBtn = document.getElementById('cancel-field-btn');
        const addFieldBtn = document.getElementById('add-field-btn');
        const extractedTextContainer = document.getElementById('extracted-text-container');
        const extractedTextEl = document.getElementById('extracted-text');
        const extractedTextInput = document.getElementById('extracted-text-input');
        
        // PDF.js variables
        let pdfDoc = null;
        let currentPage = 1;
        let scale = 1.0;
        let pdfRendering = false;
        
        // Field selection variables
        let isSelecting = false;
        let selectionStart = null;
        let currentSelection = null;
        let selectionOverlay = null;
        let editingField = null;
        
        // Load PDF document
        const loadPDF = async () => {
            try {
                // Show loading indicator
                pdfLoading.classList.remove('hidden');
                loadingStatus.textContent = 'Loading PDF...';
                
                // Get template ID from URL path - fixes incorrect template ID extraction
                const pathParts = window.location.pathname.split('/').filter(Boolean);
                // URL format is /templates/{id}/configure/ so we need the {id}
                const templateId = pathParts[pathParts.length - 2];
                
                // Check if we have authentication before loading PDF
                const pdfUrl = `/templates/${templateId}/pdf/`;
                
                // Try to fetch PDF metadata first to check authentication
                const response = await fetch(pdfUrl, {
                    method: 'HEAD',
                    credentials: 'include'
                });
                
                if (response.redirected || response.status === 401 || response.status === 403) {
                    // Authentication issue - redirect to login page
                    window.location.href = '/login/?next=' + encodeURIComponent(window.location.pathname);
                    return;
                }
                
                if (response.status === 404) {
                    loadingStatus.textContent = 'Error: PDF file not found';
                    pdfLoading.classList.add('hidden');
                    return;
                }
                
                // Load the PDF now that we've verified access
                const loadingTask = pdfjsLib.getDocument(pdfUrl);
                pdfDoc = await loadingTask.promise;
                
                pageCount.textContent = pdfDoc.numPages;
                
                // Get first page to determine original page dimensions
                const firstPage = await pdfDoc.getPage(1);
                const unscaledViewport = firstPage.getViewport({ scale: 1.0 });
                
                // Store the original dimensions for use across all zoom levels
                if (pageResolutionEl) {
                    pageResolutionEl.textContent = `${Math.round(unscaledViewport.width)} × ${Math.round(unscaledViewport.height)}`;
                }
                
                // After PDF is loaded, render the first page
                await renderPage(currentPage);
                
                loadingStatus.textContent = 'PDF loaded successfully';
                
                // Make sure loading indicator is hidden after everything is done
                pdfLoading.classList.add('hidden');
                
                // Render field overlays after PDF is loaded
                renderFieldOverlays();
            } catch (error) {
                console.error('Error loading PDF:', error);
                
                // Handle specific PDF.js errors
                if (error.name === 'MissingPDFException') {
                    loadingStatus.textContent = 'Error: PDF file not found or inaccessible';
                } else {
                    loadingStatus.textContent = 'Error loading PDF: ' + error.message;
                }
                
                pdfLoading.classList.add('hidden');
            }
        };
        
        // Render a page
        const renderPage = async (pageNumber) => {
            if (pdfRendering) return;
            pdfRendering = true;
            
            try {
                // Validate page number
                if (pageNumber < 1) pageNumber = 1;
                if (pdfDoc && pageNumber > pdfDoc.numPages) pageNumber = pdfDoc.numPages;
                
                // Get the page
                const page = await pdfDoc.getPage(pageNumber);
                
                // Calculate viewport with scale
                const viewport = page.getViewport({ scale });
                
                // Create a canvas for the page
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                // Create a wrapper div for the canvas with the page number as ID
                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';
                pageDiv.id = `page-${pageNumber}`;
                pageDiv.style.position = 'relative';
                pageDiv.appendChild(canvas);
                
                // Clear all pages from the container
                pdfContainer.innerHTML = '';
                
                // Add the page to the container
                pdfContainer.appendChild(pageDiv);
                
                // Render the page
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                
                await page.render(renderContext).promise;
                
                // Update current page display
                document.getElementById('page-input').value = pageNumber;
                currentPage = pageNumber;
                
                // Update buttons state
                prevPageBtn.disabled = pageNumber <= 1;
                nextPageBtn.disabled = pageNumber >= pdfDoc.numPages;
                
                // Render field overlays for this page
                renderFieldOverlays();
                
                // Make sure loading indicator is hidden
                pdfLoading.classList.add('hidden');
                loadingStatus.textContent = 'PDF loaded successfully';
                
                pdfRendering = false;
            } catch (error) {
                console.error('Error rendering page:', error);
                pdfRendering = false;
                pdfLoading.classList.add('hidden');
            }
        };
        
        // Render field overlays
        const renderFieldOverlays = () => {
            // Remove existing overlays
            document.querySelectorAll('.field-overlay').forEach(overlay => overlay.remove());
            
            // Get fields for current page
            const fields = Array.from(document.querySelectorAll('.field-item'))
                .filter(item => {
                    // Find the span containing "Page:" text
                    const spans = Array.from(item.querySelectorAll('.text-gray-500'));
                    const pageSpan = spans.find(span => span.textContent.includes('Page:'));
                    if (!pageSpan) return false;
                    
                    const fieldPage = parseInt(pageSpan.nextSibling.textContent.trim());
                    return fieldPage === currentPage;
                });
            
            fields.forEach(field => {
                const fieldId = field.dataset.fieldId;
                const fieldName = field.querySelector('h3').textContent;
                
                // Extract coordinates using the same approach
                const spans = Array.from(field.querySelectorAll('.text-gray-500'));
                const positionSpan = spans.find(span => span.textContent.includes('Position:'));
                const sizeSpan = spans.find(span => span.textContent.includes('Size:'));
                
                if (!positionSpan || !sizeSpan) return;
                
                const positionText = positionSpan.nextSibling.textContent.trim();
                const sizeText = sizeSpan.nextSibling.textContent.trim();
                
                const [x, y] = positionText.replace(/[()]/g, '').split(',').map(coord => parseFloat(coord.trim()));
                const [width, height] = sizeText.split('x').map(dim => parseFloat(dim.trim()));
                
                // Create overlay
                createFieldOverlay(fieldId, fieldName, x, y, width, height);
            });
        };
        
        // Create a field overlay
        const createFieldOverlay = (fieldId, fieldName, x, y, width, height) => {
            const pageCanvas = document.querySelector(`#page-${currentPage} canvas`);
            if (!pageCanvas) return;
            
            const pageDiv = document.getElementById(`page-${currentPage}`);
            const overlay = document.createElement('div');
            overlay.className = 'field-overlay';
            overlay.dataset.fieldId = fieldId;
            
            // Apply current scale to position the overlay correctly
            overlay.style.left = `${x * scale}px`;
            overlay.style.top = `${y * scale}px`;
            overlay.style.width = `${width * scale}px`;
            overlay.style.height = `${height * scale}px`;
            
            // Add field name label
            const label = document.createElement('div');
            label.className = 'field-label';
            label.textContent = fieldName;
            overlay.appendChild(label);
            
            // Add click handler to highlight and open edit form
            overlay.addEventListener('click', () => {
                document.querySelectorAll('.field-overlay').forEach(o => o.classList.remove('active'));
                overlay.classList.add('active');
                
                // Open edit form
                const fieldItem = document.querySelector(`.field-item[data-field-id="${fieldId}"]`);
                if (fieldItem) {
                    const editBtn = fieldItem.querySelector('.edit-field-btn');
                    if (editBtn) editBtn.click();
                }
            });
            
            pageDiv.appendChild(overlay);
        };
        
        // Handle area selection for field
        const startAreaSelection = () => {
            // Completely reset the selection state
            isSelecting = true;
            
            // Don't preset any coordinates, let them be determined by user clicks
            selectionStart = null;
            currentSelection = null;
            
            // Remove any existing event listeners to prevent duplicates
            const pageElement = document.getElementById(`page-${currentPage}`);
            pageElement.removeEventListener('mousedown', handleMouseDown);
            pageElement.removeEventListener('mousemove', handleMouseMove);
            pageElement.removeEventListener('mouseup', handleMouseUp);
            
            // Remove existing selection overlay if it exists to start fresh
            if (selectionOverlay) {
                selectionOverlay.remove();
                selectionOverlay = null;
            }
            
            // Create a brand new selection overlay
            selectionOverlay = document.createElement('div');
            selectionOverlay.className = 'selection-overlay';
            selectionOverlay.style.display = 'none'; // Hide until user clicks
            document.getElementById(`page-${currentPage}`).appendChild(selectionOverlay);
            
            // Set page in the form
            fieldPageInput.value = currentPage;
            
            // Add mouse event listeners
            pageElement.addEventListener('mousedown', handleMouseDown);
            pageElement.addEventListener('mousemove', handleMouseMove);
            pageElement.addEventListener('mouseup', handleMouseUp);
            
            // Show instructions
            loadingStatus.textContent = 'Click and drag to select an area';
        };
        
        const handleMouseDown = (e) => {
            if (!isSelecting) return;
            
            // Get the mouse position relative to the element
            const rect = e.target.getBoundingClientRect();
            selectionStart = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            // Initialize currentSelection with the start point
            currentSelection = {
                startX: selectionStart.x,
                startY: selectionStart.y,
                endX: selectionStart.x,
                endY: selectionStart.y
            };
            
            // Position the overlay exactly at the starting point with zero size
            selectionOverlay.style.left = `${selectionStart.x}px`;
            selectionOverlay.style.top = `${selectionStart.y}px`;
            selectionOverlay.style.width = '0px';
            selectionOverlay.style.height = '0px';
            selectionOverlay.style.display = 'block';
        };
        
        const handleMouseMove = (e) => {
            if (!isSelecting || !selectionStart || !selectionOverlay || !currentSelection) return;
            
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Update the end coordinates
            currentSelection.endX = mouseX;
            currentSelection.endY = mouseY;
            
            // Calculate the rectangle coordinates
            const left = Math.min(currentSelection.startX, currentSelection.endX);
            const top = Math.min(currentSelection.startY, currentSelection.endY);
            const width = Math.abs(currentSelection.endX - currentSelection.startX);
            const height = Math.abs(currentSelection.endY - currentSelection.startY);
            
            // Update overlay position and size
            selectionOverlay.style.left = `${left}px`;
            selectionOverlay.style.top = `${top}px`;
            selectionOverlay.style.width = `${width}px`;
            selectionOverlay.style.height = `${height}px`;
        };
        
        const handleMouseUp = async (e) => {
            if (!isSelecting || !currentSelection) return;
            
            // Cleanup event listeners
            const pageElement = document.getElementById(`page-${currentPage}`);
            pageElement.removeEventListener('mousedown', handleMouseDown);
            pageElement.removeEventListener('mousemove', handleMouseMove);
            pageElement.removeEventListener('mouseup', handleMouseUp);
            
            // Calculate the final rectangle coordinates
            const x = Math.min(currentSelection.startX, currentSelection.endX);
            const y = Math.min(currentSelection.startY, currentSelection.endY);
            const width = Math.abs(currentSelection.endX - currentSelection.startX);
            const height = Math.abs(currentSelection.endY - currentSelection.startY);
            
            // Store the coordinates normalized to 1.0 scale (for backend processing)
            const normalizedSelection = {
                x: x / scale,
                y: y / scale,
                x1: width / scale,
                y1: height / scale
            };
            
            // Update form with the normalized values (at 1.0 scale)
            fieldXInput.value = normalizedSelection.x.toFixed(2);
            fieldYInput.value = normalizedSelection.y.toFixed(2);
            fieldX1Input.value = normalizedSelection.x1.toFixed(2);
            fieldY1Input.value = normalizedSelection.y1.toFixed(2);
            
            // Extract text from the selected area using normalized coordinates
            await extractTextFromArea(normalizedSelection);
            
            // Show form after selection
            inlineFieldForm.classList.remove('hidden');
            isSelecting = false;
            
            // Completely reset selection state
            selectionStart = null;
            currentSelection = null;
            
            loadingStatus.textContent = 'Area selected';
            
            // Hide selection overlay after form is shown
            if (selectionOverlay) {
                selectionOverlay.style.display = 'none';
            }
        };
        
        // Extract text from selected area
        const extractTextFromArea = async (selection) => {
            try {
                // Get template ID from URL path, using same logic as loadPDF
                const pathParts = window.location.pathname.split('/').filter(Boolean);
                const templateId = pathParts[pathParts.length - 2];
                
                // Send the normalized coordinates (at 1.0 scale) to the backend
                const response = await fetch(`/templates/${templateId}/extract-text/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                    },
                    body: JSON.stringify({
                        x: selection.x,
                        y: selection.y,
                        x1: selection.x + selection.x1,
                        y1: selection.y + selection.y1,
                        page: currentPage
                    })
                });
                
                const data = await response.json();
                
                if (data.status === 'success' && data.text) {
                    extractedTextContainer.classList.remove('hidden');
                    extractedTextEl.textContent = data.text;
                    extractedTextInput.value = data.text;
                } else {
                    extractedTextContainer.classList.add('hidden');
                    extractedTextEl.textContent = '';
                    extractedTextInput.value = '';
                }
            } catch (error) {
                console.error('Error extracting text:', error);
                extractedTextContainer.classList.add('hidden');
            }
        };
        
        // Initialize
        loadPDF();
        loadConfigurationData();
        
        // Load configuration data for dropdown
        async function loadConfigurationData() {
            try {
                // Get template ID from URL path
                const pathParts = window.location.pathname.split('/').filter(Boolean);
                const templateId = pathParts[pathParts.length - 2];
                
                // Fetch configuration data
                const response = await fetch(`/templates/${templateId}/get-configuration-data/`, {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });
                
                if (!response.ok) {
                    console.error('Failed to load configuration data');
                    return Promise.reject('Failed to load configuration data');
                }
                
                const data = await response.json();
                
                // Get the field name select element
                const fieldNameSelect = document.getElementById('field-name');
                
                // Completely clear the select element
                fieldNameSelect.innerHTML = '';
                
                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Select a field --';
                fieldNameSelect.appendChild(defaultOption);
                
                // Get all existing field names from the DOM
                const existingFieldNames = Array.from(document.querySelectorAll('.field-item h3'))
                    .map(el => el.textContent.trim());
                
                // Get current editing field name (if any)
                const currentFieldId = fieldIdInput.value;
                let currentFieldName = '';
                
                if (currentFieldId) {
                    const currentFieldElement = document.querySelector(`.field-item[data-field-id="${currentFieldId}"] h3`);
                    if (currentFieldElement) {
                        currentFieldName = currentFieldElement.textContent.trim();
                    }
                }
                
                // Add fields group
                if (data.fields && data.fields.length > 0) {
                    const fieldsGroup = document.createElement('optgroup');
                    fieldsGroup.label = 'Fields';
                    
                    data.fields.forEach(field => {
                        const option = document.createElement('option');
                        option.value = field.name;
                        option.textContent = field.name + (field.field_type ? ` (${field.field_type})` : '');
                        
                        // Disable the option if this field name is already used
                        // but allow the current field to keep its name
                        if (existingFieldNames.includes(field.name) && field.name !== currentFieldName) {
                            option.disabled = true;
                            option.textContent += ' - Already Added';
                            option.style.color = '#999';
                        }
                        
                        fieldsGroup.appendChild(option);
                    });
                    
                    fieldNameSelect.appendChild(fieldsGroup);
                }
                
                // Add tables group
                if (data.tables && data.tables.length > 0) {
                    const tablesGroup = document.createElement('optgroup');
                    tablesGroup.label = 'Tables';
                    
                    data.tables.forEach(table => {
                        const option = document.createElement('option');
                        option.value = table.name;
                        option.textContent = table.name;
                        
                        // Disable the option if this table name is already used
                        // but allow the current field to keep its name
                        if (existingFieldNames.includes(table.name) && table.name !== currentFieldName) {
                            option.disabled = true;
                            option.textContent += ' - Already Added';
                            option.style.color = '#999';
                        }
                        
                        tablesGroup.appendChild(option);
                    });
                    
                    fieldNameSelect.appendChild(tablesGroup);
                }
                
                // Populate Python functions dropdown
                const pythonFunctionSelect = document.getElementById('python-function');
                
                // Completely clear the select element
                pythonFunctionSelect.innerHTML = '';
                
                // Add default option
                const noneOption = document.createElement('option');
                noneOption.value = '';
                noneOption.textContent = '-- None --';
                pythonFunctionSelect.appendChild(noneOption);
                
                // Add Python functions
                if (data.python_functions && data.python_functions.length > 0) {
                    data.python_functions.forEach(func => {
                        const option = document.createElement('option');
                        // Ensure ID is a string for comparison in dropdown
                        option.value = String(func.id);
                        option.textContent = func.name;
                        if (func.description) {
                            option.title = func.description;
                        }
                        pythonFunctionSelect.appendChild(option);
                    });
                }
                
                return Promise.resolve(); // Explicitly return a resolved promise
                
            } catch (error) {
                console.error('Error loading configuration data:', error);
                return Promise.reject(error);
            }
        }
        
        // Navigation controls
        prevPageBtn.addEventListener('click', () => {
            if (currentPage > 1) {
                renderPage(currentPage - 1);
            }
        });
        
        nextPageBtn.addEventListener('click', () => {
            if (currentPage < pdfDoc.numPages) {
                renderPage(currentPage + 1);
            }
        });
        
        // Page input control
        pageInput.addEventListener('change', () => {
            const pageNumber = parseInt(pageInput.value);
            if (!isNaN(pageNumber) && pageNumber >= 1 && pdfDoc && pageNumber <= pdfDoc.numPages) {
                renderPage(pageNumber);
            } else {
                // Reset to current page if invalid
                pageInput.value = currentPage;
            }
        });
        
        // Handle Enter key for page input
        pageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const pageNumber = parseInt(pageInput.value);
                if (!isNaN(pageNumber) && pageNumber >= 1 && pdfDoc && pageNumber <= pdfDoc.numPages) {
                    renderPage(pageNumber);
                } else {
                    // Reset to current page if invalid
                    pageInput.value = currentPage;
                }
            }
        });
        
        // Zoom controls
        zoomInBtn.addEventListener('click', () => {
            scale += 0.25;
            zoomLevelEl.textContent = `${Math.round(scale * 100)}%`;
            renderPage(currentPage);
        });
        
        zoomOutBtn.addEventListener('click', () => {
            if (scale > 0.5) {
                scale -= 0.25;
                zoomLevelEl.textContent = `${Math.round(scale * 100)}%`;
                renderPage(currentPage);
            }
        });
        
        // Field form controls
        customNameEnabled.addEventListener('change', () => {
            customNameContainer.classList.toggle('hidden', !customNameEnabled.checked);
            
            // If custom name is enabled, focus on the custom name input
            if (customNameEnabled.checked) {
                setTimeout(() => customNameInput.focus(), 100);
            }
        });
        
        selectAreaBtn.addEventListener('click', startAreaSelection);
        
        // Form controls
        closeInlineFormBtn.addEventListener('click', () => {
            inlineFieldForm.classList.add('hidden');
            extractedTextContainer.classList.add('hidden');
            fieldForm.reset();
            fieldIdInput.value = '';
            extractedTextEl.textContent = '';
            extractedTextInput.value = '';
        });
        
        cancelFieldBtn.addEventListener('click', () => {
            inlineFieldForm.classList.add('hidden');
            extractedTextContainer.classList.add('hidden');
            fieldForm.reset();
            fieldIdInput.value = '';
            extractedTextEl.textContent = '';
            extractedTextInput.value = '';
        });
        
        // Refresh Python functions when returning from browse window
        window.addEventListener('focus', () => {
            // Only reload if the form is visible
            if (!inlineFieldForm.classList.contains('hidden')) {
                loadConfigurationData();
            }
        });
        
        // Add field button
        addFieldBtn.addEventListener('click', async () => {
            // Reset form for new field
            fieldForm.reset();
            fieldIdInput.value = '';
            customNameContainer.classList.add('hidden');
            extractedTextContainer.classList.add('hidden');
            fieldPageInput.value = currentPage;
            
            // Reload configuration data to update dropdown options
            await loadConfigurationData();
            
            // Reset Python function dropdown
            document.getElementById('python-function').selectedIndex = 0;
            
            // Scroll to the form
            inlineFieldForm.scrollIntoView({ behavior: 'smooth' });
            
            // Show form
            inlineFormTitle.textContent = 'Add Field';
            inlineFieldForm.classList.remove('hidden');
        });
        
        // Edit field buttons
        document.addEventListener('click', (e) => {
            if (e.target.closest('.edit-field-btn')) {
                const btn = e.target.closest('.edit-field-btn');
                const fieldId = btn.dataset.fieldId;
                editField(fieldId);
            }
        });
        
        // Delete field buttons
        document.addEventListener('click', (e) => {
            if (e.target.closest('.delete-field-btn')) {
                const btn = e.target.closest('.delete-field-btn');
                const fieldId = btn.dataset.fieldId;
                deleteField(fieldId);
            }
        });
        
        // Edit field function
        const editField = async (fieldId) => {
            try {
                // Get template ID from URL path, using same logic as loadPDF
                const pathParts = window.location.pathname.split('/').filter(Boolean);
                const templateId = pathParts[pathParts.length - 2];
                
                // Fetch field data
                const response = await fetch(`/templates/fields/${fieldId}/update/`, {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });
                
                const data = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(data, 'text/html');
                
                // Extract field data from the form
                const form = doc.querySelector('form');
                if (!form) return;
                
                // Set field ID first so loadConfigurationData will respect the current field
                fieldIdInput.value = fieldId;
                
                // Reload configuration data to update dropdown with respect to current field
                await loadConfigurationData();
                
                // Populate the form
                fieldNameInput.value = form.querySelector('[name="name"]').value;
                
                const customName = form.querySelector('[name="custom_name"]').value;
                if (customName) {
                    customNameEnabled.checked = true;
                    customNameContainer.classList.remove('hidden');
                    customNameInput.value = customName;
                } else {
                    customNameEnabled.checked = false;
                    customNameContainer.classList.add('hidden');
                    customNameInput.value = '';
                }
                
                fieldPageInput.value = form.querySelector('[name="page"]').value;
                fieldXInput.value = form.querySelector('[name="x"]').value;
                fieldYInput.value = form.querySelector('[name="y"]').value;
                fieldX1Input.value = form.querySelector('[name="x1"]').value;
                fieldY1Input.value = form.querySelector('[name="y1"]').value;
                
                // Set Python function if present
                const pythonFunctionSelect = document.getElementById('python-function');
                const pythonFunctionId = form.querySelector('[name="python_function"]')?.value;
                if (pythonFunctionId) {
                    for (let i = 0; i < pythonFunctionSelect.options.length; i++) {
                        if (pythonFunctionSelect.options[i].value === String(pythonFunctionId)) {
                            pythonFunctionSelect.selectedIndex = i;
                            break;
                        }
                    }
                } else {
                    pythonFunctionSelect.selectedIndex = 0; // Select "None" option
                }
                
                // Check if there's extracted text
                const fieldItem = document.querySelector(`.field-item[data-field-id="${fieldId}"]`);
                if (fieldItem) {
                    // Find the span containing "Extracted Text:" text
                    const spans = Array.from(fieldItem.querySelectorAll('.text-gray-500'));
                    const extractedTextSpan = spans.find(span => span.textContent.includes('Extracted Text:'));
                    
                    if (extractedTextSpan) {
                        const extractedText = extractedTextSpan.nextElementSibling.textContent.trim();
                        extractedTextContainer.classList.remove('hidden');
                        extractedTextEl.textContent = extractedText;
                        extractedTextInput.value = extractedText;
                    } else {
                        extractedTextContainer.classList.add('hidden');
                    }
                }
                
                // Show form
                inlineFormTitle.textContent = 'Edit Field';
                inlineFieldForm.classList.remove('hidden');
                
                // Store reference to the field being edited
                editingField = fieldId;
                
                // Go to the field's page
                const page = parseInt(fieldPageInput.value);
                if (page !== currentPage) {
                    renderPage(page);
                }
                
                // Highlight the field's overlay
                setTimeout(() => {
                    const overlay = document.querySelector(`.field-overlay[data-field-id="${fieldId}"]`);
                    if (overlay) {
                        overlay.classList.add('active');
                    }
                }, 500);
                
            } catch (error) {
                console.error('Error editing field:', error);
            }
        };
        
        // Delete field function
        const deleteField = async (fieldId) => {
            if (confirm('Are you sure you want to delete this field?')) {
                try {
                    // Get template ID from URL path, using same logic as loadPDF
                    const pathParts = window.location.pathname.split('/').filter(Boolean);
                    const templateId = pathParts[pathParts.length - 2];
                    
                    // Delete field
                    const response = await fetch(`/templates/fields/${fieldId}/delete/`, {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        // Remove field from UI
                        const fieldItem = document.querySelector(`.field-item[data-field-id="${fieldId}"]`);
                        if (fieldItem) fieldItem.remove();
                        
                        // Remove field overlay
                        const fieldOverlay = document.querySelector(`.field-overlay[data-field-id="${fieldId}"]`);
                        if (fieldOverlay) fieldOverlay.remove();
                        
                        // Show success message
                        alert('Field deleted successfully');
                    } else {
                        alert('Failed to delete field');
                    }
                } catch (error) {
                    console.error('Error deleting field:', error);
                    alert('Error deleting field');
                }
            }
        };
        
        // Save field function
        saveFieldBtn.addEventListener('click', async () => {
            try {
                // Validate required fields
                const hasFieldName = !!fieldNameInput.value;
                const hasCustomName = customNameEnabled.checked && !!customNameInput.value;
                
                // Check if at least one name is provided (either field name or custom name)
                if (!hasFieldName && !hasCustomName) {
                    alert('Please provide either a Field Name or a Custom Name');
                    return;
                }
                
                if (!fieldPageInput.value || !fieldXInput.value || !fieldYInput.value || 
                    !fieldX1Input.value || !fieldY1Input.value) {
                    alert('All position fields (Page, X, Y, Width, Height) are required');
                    return;
                }
                
                // Get form data
                const formData = new FormData(fieldForm);
                
                // If custom name is enabled but field name is empty, use custom name as the field name
                if (customNameEnabled.checked && customNameInput.value && !fieldNameInput.value) {
                    formData.set('name', customNameInput.value);
                }
                
                // Add custom name if enabled
                if (customNameEnabled.checked) {
                    formData.set('custom_name', customNameInput.value);
                } else {
                    formData.set('custom_name', '');
                }
                
                // Get template ID from URL path, using same logic as loadPDF
                const pathParts = window.location.pathname.split('/').filter(Boolean);
                const templateId = pathParts[pathParts.length - 2];
                
                let url = `/templates/${templateId}/fields/create/`;
                let method = 'POST';
                
                // If editing existing field
                if (fieldIdInput.value) {
                    url = `/templates/fields/${fieldIdInput.value}/update/`;
                    method = 'POST';
                }
                
                // Show a saving indicator
                loadingStatus.textContent = 'Saving field...';
                
                // Submit form
                const response = await fetch(url, {
                    method: method,
                    body: formData,
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });
                
                // Check if response is OK before trying to parse JSON
                if (!response.ok) {
                    const errorText = await response.text();
                    if (errorText.includes('<html') || errorText.includes('<!DOCTYPE')) {
                        // This is likely an HTML error page
                        throw new Error(`Server error: ${response.status} ${response.statusText}`);
                    } else {
                        throw new Error(`Server error: ${errorText}`);
                    }
                }
                
                // Try to parse the response as JSON
                let data;
                try {
                    data = await response.json();
                } catch (jsonError) {
                    console.error('JSON parsing error:', jsonError);
                    console.log('Response text:', await response.text());
                    throw new Error('Invalid response from server. Please try again.');
                }
                
                if (data.status === 'success') {
                    // Reload the page to update the UI
                    window.location.reload();
                } else {
                    alert(data.message || 'Failed to save field');
                }
            } catch (error) {
                console.error('Error saving field:', error);
                loadingStatus.textContent = 'Error saving field';
                alert('Error saving field: ' + error.message);
            }
        });
    });
</script>
{% endblock %} 